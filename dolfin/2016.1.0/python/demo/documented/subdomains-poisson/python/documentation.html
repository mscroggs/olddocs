

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>19. Poisson equation with multiple subdomains &mdash; FEniCS Project</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../../../../genindex.html"/>
        <link rel="search" title="Search" href="../../../../search.html"/>
    <link rel="top" title="FEniCS Project" href="../../../../index.html"/>
        <link rel="up" title="Collection of documented demos" href="../../../index.html"/>
        <link rel="next" title="20. Marking subdomains of a mesh" href="../../subdomains/python/documentation.html"/>
        <link rel="prev" title="18. Stokes equations with Taylor-Hood elements" href="../../stokes-taylor-hood/python/documentation.html"/> 

  
  <script src="../../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../../index.html" class="icon icon-home"> DOLFIN
          

          
          </a>

          
            
            
              <div class="version">
                2016.1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../../../programmers-reference/index.html">Programmer&#8217;s reference for DOLFIN (Python)</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../../index.html">Collection of documented demos</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../../auto-adaptive-poisson/python/documentation.html">1. Auto adaptive Poisson equation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../bcs/python/documentation.html">2. Set boundary conditions for meshes that include boundary indicators</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../biharmonic/python/documentation.html">3. Biharmonic equation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../built-in-meshes/python/documentation.html">4. Built-in meshes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../cahn-hilliard/python/documentation.html">5. Cahn-Hilliard equation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../eigenvalue/python/documentation.html">6. A simple eigenvalue solver</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../hyperelasticity/python/documentation.html">7. Hyperelasticity</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../mixed-poisson-dual/python/documentation.html">8. Dual-mixed formulation for Poisson equation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../mixed-poisson/python/documentation.html">9. Mixed formulation for Poisson equation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../navier-stokes/python/documentation.html">10. Incompressible Navier-Stokes equations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../neumann-poisson/python/documentation.html">11. Poisson equation with pure Neumann boundary conditions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../nonlinear-poisson/python/documentation.html">12. Nonlinear Poisson equation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../periodic/python/documentation.html">13. Poisson equation with periodic boundary conditions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../poisson/python/documentation.html">14. Poisson equation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../singular-poisson/python/documentation.html">15. Singular Poisson</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stokes-iterative/python/documentation.html">16. Stokes equations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stokes-mini/python/documentation.html">17. Stokes equations with Mini elements</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stokes-taylor-hood/python/documentation.html">18. Stokes equations with Taylor-Hood elements</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">19. Poisson equation with multiple subdomains</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#equation-and-problem-definition">19.1. Equation and problem definition</a></li>
<li class="toctree-l3"><a class="reference internal" href="#variational-form">19.2. Variational form</a></li>
<li class="toctree-l3"><a class="reference internal" href="#implementation">19.3. Implementation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#complete-code">19.4. Complete code</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../subdomains/python/documentation.html">20. Marking subdomains of a mesh</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../tensor-weighted-poisson/python/documentation.html">21. Tensor-weighted Poisson</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../../quick_reference.html">Quick Programmer&#8217;s Reference (Python)</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../../../index.html">DOLFIN</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../../../index.html">Docs</a> &raquo;</li>
      
          <li><a href="../../../index.html">Collection of documented demos</a> &raquo;</li>
      
    <li>19. Poisson equation with multiple subdomains</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../../../../_sources/demo/documented/subdomains-poisson/python/documentation.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="poisson-equation-with-multiple-subdomains">
<span id="demo-pde-subdomains-poisson-documentation"></span><h1>19. Poisson equation with multiple subdomains<a class="headerlink" href="#poisson-equation-with-multiple-subdomains" title="Permalink to this headline">¶</a></h1>
<p>This demo is implemented in a single Python file,
<a class="reference download internal" href="../../../../_downloads/demo_subdomains-poisson.py" download=""><code class="xref download docutils literal"><span class="pre">demo_subdomains-poisson.py</span></code></a>, which contains both the
variational forms and the solver. We suggest that you familiarize
yourself with the <a class="reference internal" href="../../poisson/python/documentation.html#demo-pde-poisson-python-documentation"><span class="std std-ref">Poisson demo</span></a> before studying this example,
as some of the more standard steps will be described in less detail.</p>
<p>The main purpose of this demo is to demonstrate how to create and
integrate variational forms over distinct regions of a domain and/or
its boundaries.</p>
<div class="section" id="equation-and-problem-definition">
<h2>19.1. Equation and problem definition<a class="headerlink" href="#equation-and-problem-definition" title="Permalink to this headline">¶</a></h2>
<p>For illustration purposes, we consider a weighted Poisson equation over
a unit square: <span class="math">\(\Omega = [0,1] \times [0,1]\)</span> with mixed boundary
conditions: find <span class="math">\(u\)</span> satisfying</p>
<div class="math">
\[\begin{split}- \mathrm{div} (a \nabla u) &amp;= 1.0 \quad {\rm in} \ \Omega, \\
               u &amp;= 5.0 \quad {\rm on} \ \Gamma_{T}, \\
               u &amp;= 0.0 \quad {\rm on} \ \Gamma_{B}, \\
               \nabla u \cdot n &amp;= - 10.0 \, e^{-(y - 0.5)^2} \quad {\rm on} \ \Gamma_{L}. \\
               \nabla u \cdot n &amp;= 1.0 \quad {\rm on} \ \Gamma_{R}, \\\end{split}\]</div>
<p>where <span class="math">\(\Gamma_{T}\)</span>, <span class="math">\(\Gamma_{B}\)</span>, <span class="math">\(\Gamma_{L}\)</span>,
<span class="math">\(\Gamma_{R}\)</span> denote the top, bottom, left and right sides of the
unit square, respectively. The coefficient <span class="math">\(a\)</span> may vary over the
domain: here, we let <span class="math">\(a = a_1 = 0.01\)</span> for <span class="math">\((x, y) \in
\Omega_1 = [0.5, 0.7] \times [0.2, 1.0]\)</span> and <span class="math">\(a = a_0 = 1.0\)</span> in
<span class="math">\(\Omega_0 = \Omega \backslash \Omega_1\)</span>. We can think of
<span class="math">\(\Omega_1\)</span> as an obstacle with differing material properties
from the rest of the domain.</p>
</div>
<div class="section" id="variational-form">
<h2>19.2. Variational form<a class="headerlink" href="#variational-form" title="Permalink to this headline">¶</a></h2>
<p>We can write the above boundary value problem in the standard linear
variational form: find <span class="math">\(u \in V\)</span> such that</p>
<div class="math">
\[a(u, v) = L(v) \quad \forall \ v \in \hat{V},\]</div>
<p>where <span class="math">\(V\)</span> and <span class="math">\(\hat{V}\)</span> are suitable function spaces
incorporating the Dirichlet boundary conditions on <span class="math">\(\Gamma_{T}\)</span>
and <span class="math">\(\Gamma_{B}\)</span>, and</p>
<div class="math">
\[\begin{split}a(u, v) &amp;= \int_{\Omega_0} a_0 \nabla u \cdot \nabla v \, {\rm d} x
         + \int_{\Omega_1} a_1 \nabla u \cdot \nabla v \, {\rm d} x, \\
L(v)      &amp;=  \int_{\Gamma_{L}} g_L v \, {\rm d} s
         + \int_{\Gamma_{R}} g_R v \, {\rm d} s
         + \int_{\Omega} f \, v \, {\rm d} x.\end{split}\]</div>
<p>where <span class="math">\(f = 1.0\)</span>, <span class="math">\(g_L = - 10.0 e^{-(y - 0.5)^2}\)</span> and
<span class="math">\(g_R = 1.0\)</span>.</p>
</div>
<div class="section" id="implementation">
<h2>19.3. Implementation<a class="headerlink" href="#implementation" title="Permalink to this headline">¶</a></h2>
<p>This description goes through the implementation (in
<a class="reference download internal" href="../../../../_downloads/demo_subdomains-poisson.py" download=""><code class="xref download docutils literal"><span class="pre">demo_subdomains-poisson.py</span></code></a>) of a solver for the above
described equation.</p>
<p>In this example, different boundary conditions are prescribed on
different parts of the boundaries, and different parts of the interior
have different material properties. This information must be made
available to the solver.  One way of doing this, is to tag the
different subregions with different (integer) labels, and later
integrate over the specified regions. DOLFIN provides a class
<code class="xref py py-class docutils literal"><span class="pre">MeshFunction</span></code> which is useful for
these types of operations: instances of this class represent functions
over mesh entities (such as over cells or over facets). Mesh functions
can be read from file or, if explicit formulae for the domains are
known, they can be constructed by way of instances of the
<code class="xref py py-class docutils literal"><span class="pre">SubDomain</span></code> class. The latter is the
case here, so we begin by defining the left, right, top and bottom
boundaries, and the interior obstacle domain using the
<code class="xref py py-class docutils literal"><span class="pre">SubDomain</span></code> class and creating
instances of these classes.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">dolfin</span> <span class="kn">import</span> <span class="o">*</span>

<span class="c1"># Create classes for defining parts of the boundaries and the interior</span>
<span class="c1"># of the domain</span>
<span class="k">class</span> <span class="nc">Left</span><span class="p">(</span><span class="n">SubDomain</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">inside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">near</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mf">0.0</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Right</span><span class="p">(</span><span class="n">SubDomain</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">inside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">near</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mf">1.0</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Bottom</span><span class="p">(</span><span class="n">SubDomain</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">inside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">near</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mf">0.0</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Top</span><span class="p">(</span><span class="n">SubDomain</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">inside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">near</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mf">1.0</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Obstacle</span><span class="p">(</span><span class="n">SubDomain</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">inside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">between</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">))</span> <span class="ow">and</span> <span class="n">between</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)))</span>

<span class="c1"># Initialize sub-domain instances</span>
<span class="n">left</span> <span class="o">=</span> <span class="n">Left</span><span class="p">()</span>
<span class="n">top</span> <span class="o">=</span> <span class="n">Top</span><span class="p">()</span>
<span class="n">right</span> <span class="o">=</span> <span class="n">Right</span><span class="p">()</span>
<span class="n">bottom</span> <span class="o">=</span> <span class="n">Bottom</span><span class="p">()</span>
<span class="n">obstacle</span> <span class="o">=</span> <span class="n">Obstacle</span><span class="p">()</span>
</pre></div>
</div>
<p>Note that the DOLFIN functions <code class="xref py py-func docutils literal"><span class="pre">near</span></code> and
<code class="xref py py-func docutils literal"><span class="pre">between</span></code> provide robust ways of testing
whether a coordinate is (to within machine precision) close to a given
numerical value and in a range of values, respectively.</p>
<p>We next define a mesh of the domain:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitSquareMesh</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>
</pre></div>
</div>
<p>The above subdomains are defined with the sole purpose of populating
mesh functions. (For more complicated geometries, the mesh functions
would typically be provided by other means.) The classes
<code class="xref py py-class docutils literal"><span class="pre">CellFunction</span></code> and
<code class="xref py py-class docutils literal"><span class="pre">FacetFunction</span></code> are specialized
versions of the more general <code class="xref py py-class docutils literal"><span class="pre">MeshFunction</span></code>. <code class="xref py py-class docutils literal"><span class="pre">CellFunction</span></code> represents a function with a value for each
cell of a mesh, while <code class="xref py py-class docutils literal"><span class="pre">FacetFunction</span></code> represents a function with a value for
each facet. We define a <code class="xref py py-class docutils literal"><span class="pre">CellFunction</span></code> to indicate which cells that correspond to
the different interior subregions <span class="math">\(\Omega_0\)</span> and
<span class="math">\(\Omega_1\)</span>. Those in the interior rectangle will be tagged by
<cite>1</cite>, while the remainder is tagged by <cite>0</cite>. We can set all the values
of a <code class="xref py py-class docutils literal"><span class="pre">MeshFunction</span></code> to a given
value using the <code class="xref py py-func docutils literal"><span class="pre">set_all</span></code> method.  So, in order to
accomplish what we want, we can set all values to <cite>0</cite> first, and then
we can use the <code class="docutils literal"><span class="pre">obstacle</span></code> instance to mark the cells identified as
inside the obstacle region by <cite>1</cite> (thus overwriting the previous
value):</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Initialize mesh function for interior domains</span>
<span class="n">domains</span> <span class="o">=</span> <span class="n">CellFunction</span><span class="p">(</span><span class="s2">&quot;size_t&quot;</span><span class="p">,</span> <span class="n">mesh</span><span class="p">)</span>
<span class="n">domains</span><span class="o">.</span><span class="n">set_all</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">obstacle</span><span class="o">.</span><span class="n">mark</span><span class="p">(</span><span class="n">domains</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>We can do the same for the boundaries using a <code class="xref py py-class docutils literal"><span class="pre">FacetFunction</span></code>. We first tag all the edges by <code class="docutils literal"><span class="pre">0</span></code>, then
the edges on the left by <code class="docutils literal"><span class="pre">1</span></code>, on the top by <code class="docutils literal"><span class="pre">2</span></code>, on the right by
<code class="docutils literal"><span class="pre">3</span></code> and on the bottom by <code class="docutils literal"><span class="pre">4</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Initialize mesh function for boundary domains</span>
<span class="n">boundaries</span> <span class="o">=</span> <span class="n">FacetFunction</span><span class="p">(</span><span class="s2">&quot;size_t&quot;</span><span class="p">,</span> <span class="n">mesh</span><span class="p">)</span>
<span class="n">boundaries</span><span class="o">.</span><span class="n">set_all</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">left</span><span class="o">.</span><span class="n">mark</span><span class="p">(</span><span class="n">boundaries</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">top</span><span class="o">.</span><span class="n">mark</span><span class="p">(</span><span class="n">boundaries</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">right</span><span class="o">.</span><span class="n">mark</span><span class="p">(</span><span class="n">boundaries</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">bottom</span><span class="o">.</span><span class="n">mark</span><span class="p">(</span><span class="n">boundaries</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
<p>Now that the geometry is defined and labeled, we can move on to
defining the input source functions:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Define input data</span>
<span class="n">a0</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>
<span class="n">a1</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mf">0.01</span><span class="p">)</span>
<span class="n">g_L</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s2">&quot;- 10*exp(- pow(x[1] - 0.5, 2))&quot;</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">g_R</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>
</pre></div>
</div>
<p>Here, <code class="docutils literal"><span class="pre">a0</span></code> and <code class="docutils literal"><span class="pre">a1</span></code> represent the values of the coefficient
<span class="math">\(a\)</span> in the two regions of the domain, <code class="docutils literal"><span class="pre">g_L</span></code> and <code class="docutils literal"><span class="pre">g_R</span></code>
represent the values of the Neumann boundary condition on the left and
right boundaries respectively, and <code class="docutils literal"><span class="pre">f</span></code> represents the body source.</p>
<p>We may now move on to define the variational equation. As usual, we
start by defining a finite element function space and basis functions
on this space:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Define function space and basis functions</span>
<span class="n">V</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s2">&quot;CG&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
</pre></div>
</div>
<p>With this function space, we can define the essential (Dirichlet)
boundary conditions on the top and bottom boundaries. These boundaries
correspond to the facets tagged by <code class="docutils literal"><span class="pre">2</span></code> and <code class="docutils literal"><span class="pre">4</span></code>, respectively, in
the <code class="docutils literal"><span class="pre">boundaries</span></code> facet function:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Define Dirichlet boundary conditions at top and bottom boundaries</span>
<span class="n">bcs</span> <span class="o">=</span> <span class="p">[</span><span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">,</span> <span class="n">boundaries</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
       <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">boundaries</span><span class="p">,</span> <span class="mi">4</span><span class="p">)]</span>
</pre></div>
</div>
<p>DOLFIN predefines the &#8220;measures&#8221; <code class="docutils literal"><span class="pre">dx</span></code>, <code class="docutils literal"><span class="pre">ds</span></code> and <code class="docutils literal"><span class="pre">dS</span></code>
representing integration over cells, exterior facets (that is, facets
on the boundary) and interior facets, respectively. These measures can
take an additional integer argument.  In fact, <code class="docutils literal"><span class="pre">dx</span></code> defaults to
<code class="docutils literal"><span class="pre">dx(0)</span></code>, <code class="docutils literal"><span class="pre">ds</span></code> defaults to <code class="docutils literal"><span class="pre">ds(0)</span></code>, and <code class="docutils literal"><span class="pre">dS</span></code> defaults to
<code class="docutils literal"><span class="pre">dS(0)</span></code>. Integration over subregions can be specified by measures
with different integer labels as arguments. However, we also need to
map the geometry information stored in the mesh functions to these
measures. The easiest way of accomplishing this is to define new
measures with the mesh functions as additional input:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Define new measures associated with the interior domains and</span>
<span class="c1"># exterior boundaries</span>
<span class="n">dx</span> <span class="o">=</span> <span class="n">Measure</span><span class="p">(</span><span class="s1">&#39;dx&#39;</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="n">mesh</span><span class="p">,</span> <span class="n">subdomain_data</span><span class="o">=</span><span class="n">domains</span><span class="p">)</span>
<span class="n">ds</span> <span class="o">=</span> <span class="n">Measure</span><span class="p">(</span><span class="s1">&#39;ds&#39;</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="n">mesh</span><span class="p">,</span> <span class="n">subdomain_data</span><span class="o">=</span><span class="n">boundaries</span><span class="p">)</span>
</pre></div>
</div>
<p>We can now define the variational forms corresponding to the
variational problem above using these measures and the tags for the
different subregions. For simplicity, we define the full form first,
and then extract the left- and right-hand sides using the UFL
functions <code class="xref py py-func docutils literal"><span class="pre">lhs()</span></code> and <code class="xref py py-func docutils literal"><span class="pre">rhs()</span></code> afterwards. We can then
<a class="reference internal" href="../../../../programmers-reference/fem/solving/solve.html#dolfin.fem.solving.solve" title="dolfin.fem.solving.solve"><code class="xref py py-func docutils literal"><span class="pre">solve</span></code></a> as usual:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Define variational form</span>
<span class="n">F</span> <span class="o">=</span> <span class="p">(</span><span class="n">inner</span><span class="p">(</span><span class="n">a0</span><span class="o">*</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">inner</span><span class="p">(</span><span class="n">a1</span><span class="o">*</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
     <span class="o">-</span> <span class="n">g_L</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">ds</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">g_R</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">ds</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
     <span class="o">-</span> <span class="n">f</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">f</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>

<span class="c1"># Separate left and right hand sides of equation</span>
<span class="n">a</span><span class="p">,</span> <span class="n">L</span> <span class="o">=</span> <span class="n">lhs</span><span class="p">(</span><span class="n">F</span><span class="p">),</span> <span class="n">rhs</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>

<span class="c1"># Solve problem</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">solve</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">L</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bcs</span><span class="p">)</span>
</pre></div>
</div>
<p>Now, we can also evaluate various integrals of the solution or derived
quantities of the solution over different regions, here are some
examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Evaluate integral of normal gradient over top boundary</span>
<span class="n">n</span> <span class="o">=</span> <span class="n">FacetNormal</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
<span class="n">m1</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">n</span><span class="p">)</span><span class="o">*</span><span class="n">ds</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">v1</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">m1</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s2">&quot;\int grad(u) * n ds(2) = &quot;</span><span class="p">,</span> <span class="n">v1</span><span class="p">)</span>

<span class="c1"># Evaluate integral of u over the obstacle</span>
<span class="n">m2</span> <span class="o">=</span> <span class="n">u</span><span class="o">*</span><span class="n">dx</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">v2</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">m2</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s2">&quot;\int u dx(1) = &quot;</span><span class="p">,</span> <span class="n">v2</span><span class="p">)</span>
</pre></div>
</div>
<p>We also plot the solution and its gradient:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Plot solution and gradient</span>
<span class="n">plot</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s2">&quot;u&quot;</span><span class="p">)</span>
<span class="n">plot</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">title</span><span class="o">=</span><span class="s2">&quot;Projected grad(u)&quot;</span><span class="p">)</span>
<span class="n">interactive</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="complete-code">
<h2>19.4. Complete code<a class="headerlink" href="#complete-code" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default"><div class="highlight"><pre><span></span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span>
<span class="kn">from</span> <span class="nn">dolfin</span> <span class="k">import</span> <span class="o">*</span>

<span class="c1"># Create classes for defining parts of the boundaries and the interior</span>
<span class="c1"># of the domain</span>
<span class="k">class</span> <span class="nc">Left</span><span class="p">(</span><span class="n">SubDomain</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">inside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">near</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mf">0.0</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Right</span><span class="p">(</span><span class="n">SubDomain</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">inside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">near</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mf">1.0</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Bottom</span><span class="p">(</span><span class="n">SubDomain</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">inside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">near</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mf">0.0</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Top</span><span class="p">(</span><span class="n">SubDomain</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">inside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">near</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mf">1.0</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Obstacle</span><span class="p">(</span><span class="n">SubDomain</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">inside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">between</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">))</span> <span class="ow">and</span> <span class="n">between</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)))</span>

<span class="c1"># Initialize sub-domain instances</span>
<span class="n">left</span> <span class="o">=</span> <span class="n">Left</span><span class="p">()</span>
<span class="n">top</span> <span class="o">=</span> <span class="n">Top</span><span class="p">()</span>
<span class="n">right</span> <span class="o">=</span> <span class="n">Right</span><span class="p">()</span>
<span class="n">bottom</span> <span class="o">=</span> <span class="n">Bottom</span><span class="p">()</span>
<span class="n">obstacle</span> <span class="o">=</span> <span class="n">Obstacle</span><span class="p">()</span>

<span class="c1"># Define mesh</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitSquareMesh</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>

<span class="c1"># Initialize mesh function for interior domains</span>
<span class="n">domains</span> <span class="o">=</span> <span class="n">CellFunction</span><span class="p">(</span><span class="s2">&quot;size_t&quot;</span><span class="p">,</span> <span class="n">mesh</span><span class="p">)</span>
<span class="n">domains</span><span class="o">.</span><span class="n">set_all</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">obstacle</span><span class="o">.</span><span class="n">mark</span><span class="p">(</span><span class="n">domains</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="c1"># Initialize mesh function for boundary domains</span>
<span class="n">boundaries</span> <span class="o">=</span> <span class="n">FacetFunction</span><span class="p">(</span><span class="s2">&quot;size_t&quot;</span><span class="p">,</span> <span class="n">mesh</span><span class="p">)</span>
<span class="n">boundaries</span><span class="o">.</span><span class="n">set_all</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">left</span><span class="o">.</span><span class="n">mark</span><span class="p">(</span><span class="n">boundaries</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">top</span><span class="o">.</span><span class="n">mark</span><span class="p">(</span><span class="n">boundaries</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">right</span><span class="o">.</span><span class="n">mark</span><span class="p">(</span><span class="n">boundaries</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">bottom</span><span class="o">.</span><span class="n">mark</span><span class="p">(</span><span class="n">boundaries</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>

<span class="c1"># Define input data</span>
<span class="n">a0</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>
<span class="n">a1</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mf">0.01</span><span class="p">)</span>
<span class="n">g_L</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s2">&quot;- 10*exp(- pow(x[1] - 0.5, 2))&quot;</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">g_R</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>

<span class="c1"># Define function space and basis functions</span>
<span class="n">V</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s2">&quot;CG&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>

<span class="c1"># Define Dirichlet boundary conditions at top and bottom boundaries</span>
<span class="n">bcs</span> <span class="o">=</span> <span class="p">[</span><span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">,</span> <span class="n">boundaries</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
       <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">boundaries</span><span class="p">,</span> <span class="mi">4</span><span class="p">)]</span>

<span class="c1"># Define new measures associated with the interior domains and</span>
<span class="c1"># exterior boundaries</span>
<span class="n">dx</span> <span class="o">=</span> <span class="n">Measure</span><span class="p">(</span><span class="s1">&#39;dx&#39;</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="n">mesh</span><span class="p">,</span> <span class="n">subdomain_data</span><span class="o">=</span><span class="n">domains</span><span class="p">)</span>
<span class="n">ds</span> <span class="o">=</span> <span class="n">Measure</span><span class="p">(</span><span class="s1">&#39;ds&#39;</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="n">mesh</span><span class="p">,</span> <span class="n">subdomain_data</span><span class="o">=</span><span class="n">boundaries</span><span class="p">)</span>

<span class="c1"># Define variational form</span>
<span class="n">F</span> <span class="o">=</span> <span class="p">(</span><span class="n">inner</span><span class="p">(</span><span class="n">a0</span><span class="o">*</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">inner</span><span class="p">(</span><span class="n">a1</span><span class="o">*</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
     <span class="o">-</span> <span class="n">g_L</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">ds</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">g_R</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">ds</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
     <span class="o">-</span> <span class="n">f</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">f</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>

<span class="c1"># Separate left and right hand sides of equation</span>
<span class="n">a</span><span class="p">,</span> <span class="n">L</span> <span class="o">=</span> <span class="n">lhs</span><span class="p">(</span><span class="n">F</span><span class="p">),</span> <span class="n">rhs</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>

<span class="c1"># Solve problem</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">solve</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">L</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bcs</span><span class="p">)</span>

<span class="c1"># Evaluate integral of normal gradient over top boundary</span>
<span class="n">n</span> <span class="o">=</span> <span class="n">FacetNormal</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
<span class="n">m1</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">n</span><span class="p">)</span><span class="o">*</span><span class="n">ds</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">v1</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">m1</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;\int grad(u) * n ds(2) = &quot;</span><span class="p">,</span> <span class="n">v1</span><span class="p">)</span>

<span class="c1"># Evaluate integral of u over the obstacle</span>
<span class="n">m2</span> <span class="o">=</span> <span class="n">u</span><span class="o">*</span><span class="n">dx</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">v2</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">m2</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;\int u dx(1) = &quot;</span><span class="p">,</span> <span class="n">v2</span><span class="p">)</span>

<span class="c1"># Plot solution and gradient</span>
<span class="n">plot</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s2">&quot;u&quot;</span><span class="p">)</span>
<span class="n">plot</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">title</span><span class="o">=</span><span class="s2">&quot;Projected grad(u)&quot;</span><span class="p">)</span>
<span class="n">interactive</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../../subdomains/python/documentation.html" class="btn btn-neutral float-right" title="20. Marking subdomains of a mesh" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="../../stokes-taylor-hood/python/documentation.html" class="btn btn-neutral" title="18. Stokes equations with Taylor-Hood elements" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright FEniCS Project, https://bitbucket.org/fenics-project/.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../../',
            VERSION:'2016.1.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>