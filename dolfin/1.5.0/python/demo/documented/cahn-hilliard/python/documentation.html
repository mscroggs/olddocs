

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>5. Cahn-Hilliard equation &mdash; FEniCS Project</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../../../../genindex.html"/>
        <link rel="search" title="Search" href="../../../../search.html"/>
    <link rel="top" title="FEniCS Project" href="../../../../index.html"/>
        <link rel="up" title="Collection of documented demos" href="../../../index.html"/>
        <link rel="next" title="6. A simple eigenvalue solver" href="../../eigenvalue/python/documentation.html"/>
        <link rel="prev" title="4. Built-in meshes" href="../../built-in_meshes/python/documentation.html"/> 

  
  <script src="../../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../../index.html" class="icon icon-home"> DOLFIN
          

          
          </a>

          
            
            
              <div class="version">
                1.5.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../../../programmers-reference/index.html">Programmer&#8217;s reference for DOLFIN (Python)</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../../index.html">Collection of documented demos</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../../auto-adaptive-poisson/python/documentation.html">1. Auto adaptive Poisson equation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../bcs/python/documentation.html">2. Set boundary conditions for meshes that include boundary indicators</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../biharmonic/python/documentation.html">3. Biharmonic equation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../built-in_meshes/python/documentation.html">4. Built-in meshes</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">5. Cahn-Hilliard equation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#equation-and-problem-definition">5.1. Equation and problem definition</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#mixed-form">5.1.1. Mixed form</a></li>
<li class="toctree-l4"><a class="reference internal" href="#time-discretisation">5.1.2. Time discretisation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#demo-parameters">5.1.3. Demo parameters</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#implementation">5.2. Implementation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#complete-code">5.3. Complete code</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../eigenvalue/python/documentation.html">6. A simple eigenvalue solver</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../hyperelasticity/python/documentation.html">7. Hyperelasticity</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../mixed-poisson-dual/python/documentation.html">8. Dual-mixed formulation for Poisson equation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../mixed-poisson/python/documentation.html">9. Mixed formulation for Poisson equation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../navier-stokes/python/documentation.html">10. Incompressible Navier-Stokes equations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../neumann-poisson/python/documentation.html">11. Poisson equation with pure Neumann boundary conditions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../nonlinear-poisson/python/documentation.html">12. Nonlinear Poisson equation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../periodic/python/documentation.html">13. Poisson equation with periodic boundary conditions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../poisson/python/documentation.html">14. Poisson equation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../singular-poisson/python/documentation.html">15. Singular Poisson</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stokes-iterative/python/documentation.html">16. Stokes equations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stokes-mini/python/documentation.html">17. Stokes equations with Mini elements</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stokes-stabilized/python/documentation.html">18. Stokes equations with stabilized first order elements</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../stokes-taylor-hood/python/documentation.html">19. Stokes equations with Taylor-Hood elements</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../subdomains-poisson/python/documentation.html">20. Poisson equation with multiple subdomains</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../subdomains/python/documentation.html">21. Marking subdomains of a mesh</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../tensor-weighted-poisson/python/documentation.html">22. Tensor-weighted Poisson</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../../quick_reference.html">Quick Programmer&#8217;s Reference (Python)</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../../../index.html">DOLFIN</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../../../index.html">Docs</a> &raquo;</li>
      
          <li><a href="../../../index.html">Collection of documented demos</a> &raquo;</li>
      
    <li>5. Cahn-Hilliard equation</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../../../../_sources/demo/documented/cahn-hilliard/python/documentation.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="cahn-hilliard-equation">
<span id="demo-pde-cahn-hilliard-python-documentation"></span><h1>5. Cahn-Hilliard equation<a class="headerlink" href="#cahn-hilliard-equation" title="Permalink to this headline">¶</a></h1>
<p>This demo is implemented in a single Python file,
<a class="reference download internal" href="../../../../_downloads/demo_cahn-hilliard.py" download=""><code class="xref download docutils literal"><span class="pre">demo_cahn-hilliard.py</span></code></a>, which contains both the variational
forms and the solver.</p>
<p>This example demonstrates the solution of a particular nonlinear
time-dependent fourth-order equation, known as the Cahn-Hilliard
equation. In particular it demonstrates the use of</p>
<ul class="simple">
<li>The built-in Newton solver</li>
<li>Advanced use of the base class <code class="docutils literal"><span class="pre">NonlinearProblem</span></code></li>
<li>Automatic linearisation</li>
<li>A mixed finite element method</li>
<li>The <span class="math">\(\theta\)</span>-method for time-dependent equations</li>
<li>User-defined Expressions as Python classes</li>
<li>Form compiler options</li>
<li>Interpolation of functions</li>
</ul>
<div class="section" id="equation-and-problem-definition">
<h2>5.1. Equation and problem definition<a class="headerlink" href="#equation-and-problem-definition" title="Permalink to this headline">¶</a></h2>
<p>The Cahn-Hilliard equation is a parabolic equation and is typically used
to model phase separation in binary mixtures.  It involves first-order
time derivatives, and second- and fourth-order spatial derivatives.
The equation reads:</p>
<div class="math">
\[\begin{split}\frac{\partial c}{\partial t} - \nabla \cdot M \left(\nabla\left(\frac{d f}{d c}
          - \lambda \nabla^{2}c\right)\right) &amp;= 0 \quad {\rm in} \ \Omega, \\
M\left(\nabla\left(\frac{d f}{d c} - \lambda \nabla^{2}c\right)\right) &amp;= 0 \quad {\rm on} \ \partial\Omega, \\
M \lambda \nabla c \cdot n &amp;= 0 \quad {\rm on} \ \partial\Omega.\end{split}\]</div>
<p>where <span class="math">\(c\)</span> is the unknown field, the function <span class="math">\(f\)</span> is usually
non-convex in <span class="math">\(c\)</span> (a fourth-order polynomial is commonly used),
<span class="math">\(n\)</span> is the outward directed boundary normal, and <span class="math">\(M\)</span> is a
scalar parameter.</p>
<div class="section" id="mixed-form">
<h3>5.1.1. Mixed form<a class="headerlink" href="#mixed-form" title="Permalink to this headline">¶</a></h3>
<p>The Cahn-Hilliard equation is a fourth-order equation, so casting it
in a weak form would result in the presence of second-order spatial
derivatives, and the problem could not be solved using a standard
Lagrange finite element basis.  A solution is to rephrase the problem
as two coupled second-order equations:</p>
<div class="math">
\[\begin{split}\frac{\partial c}{\partial t} - \nabla \cdot M \nabla\mu  &amp;= 0 \quad {\rm in} \ \Omega, \\
\mu -  \frac{d f}{d c} + \lambda \nabla^{2}c &amp;= 0 \quad {\rm in} \ \Omega.\end{split}\]</div>
<p>The unknown fields are now <span class="math">\(c\)</span> and <span class="math">\(\mu\)</span>. The weak
(variational) form of the problem reads: find <span class="math">\((c, \mu) \in V
\times V\)</span> such that</p>
<div class="math">
\[\begin{split}\int_{\Omega} \frac{\partial c}{\partial t} q \, {\rm d} x + \int_{\Omega} M \nabla\mu \cdot \nabla q \, {\rm d} x
       &amp;= 0 \quad \forall \ q \in V,  \\
\int_{\Omega} \mu v \, {\rm d} x - \int_{\Omega} \frac{d f}{d c} v \, {\rm d} x - \int_{\Omega} \lambda \nabla c \cdot \nabla v \, {\rm d} x
       &amp;= 0 \quad \forall \ v \in V.\end{split}\]</div>
</div>
<div class="section" id="time-discretisation">
<h3>5.1.2. Time discretisation<a class="headerlink" href="#time-discretisation" title="Permalink to this headline">¶</a></h3>
<p>Before being able to solve this problem, the time derivative must be
dealt with. Apply the <span class="math">\(\theta\)</span>-method to the mixed weak form of
the equation:</p>
<div class="math">
\[\begin{split}\int_{\Omega} \frac{c_{n+1} - c_{n}}{dt} q \, {\rm d} x + \int_{\Omega} M \nabla \mu_{n+\theta} \cdot \nabla q \, {\rm d} x
       &amp;= 0 \quad \forall \ q \in V  \\
\int_{\Omega} \mu_{n+1} v  \, {\rm d} x - \int_{\Omega} \frac{d f_{n+1}}{d c} v  \, {\rm d} x - \int_{\Omega} \lambda \nabla c_{n+1} \cdot \nabla v \, {\rm d} x
       &amp;= 0 \quad \forall \ v \in V\end{split}\]</div>
<p>where <span class="math">\(dt = t_{n+1} - t_{n}\)</span>
and <span class="math">\(\mu_{n+\theta} = (1-\theta) \mu_{n} + \theta \mu_{n+1}\)</span>.
The task is: given <span class="math">\(c_{n}\)</span> and <span class="math">\(\mu_{n}\)</span>, solve the above
equation to find <span class="math">\(c_{n+1}\)</span> and <span class="math">\(\mu_{n+1}\)</span>.</p>
</div>
<div class="section" id="demo-parameters">
<h3>5.1.3. Demo parameters<a class="headerlink" href="#demo-parameters" title="Permalink to this headline">¶</a></h3>
<p>The following domains, functions and time stepping parameters are used
in this demo:</p>
<ul class="simple">
<li><span class="math">\(\Omega = (0, 1) \times (0, 1)\)</span> (unit square)</li>
<li><span class="math">\(f = 100 c^{2} (1-c)^{2}\)</span></li>
<li><span class="math">\(\lambda = 1 \times 10^{-2}\)</span></li>
<li><span class="math">\(M = 1\)</span></li>
<li><span class="math">\(dt = 5 \times 10^{-6}\)</span></li>
<li><span class="math">\(\theta = 0.5\)</span></li>
</ul>
<p>With the above input the solution for <span class="math">\(c\)</span> will look as follows:</p>
<a class="reference internal image-reference" href="../../../../_images/cahn-hilliard_c.png"><img alt="../../../../_images/cahn-hilliard_c.png" class="align-center" src="../../../../_images/cahn-hilliard_c.png" style="width: 450.0px; height: 300.0px;" /></a>
</div>
</div>
<div class="section" id="implementation">
<h2>5.2. Implementation<a class="headerlink" href="#implementation" title="Permalink to this headline">¶</a></h2>
<p>This demo is implemented in the <a class="reference download internal" href="../../../../_downloads/demo_cahn-hilliard.py" download=""><code class="xref download docutils literal"><span class="pre">demo_cahn-hilliard.py</span></code></a> file.</p>
<p>First, the Python module <a class="reference external" href="https://docs.python.org/2/library/random.html#module-random" title="(in Python v2.7)"><code class="xref py py-mod docutils literal"><span class="pre">random</span></code></a> and the <a class="reference internal" href="../../../../programmers-reference/index.html#module-dolfin" title="dolfin"><code class="xref py py-mod docutils literal"><span class="pre">dolfin</span></code></a>
module are imported:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">random</span>
<span class="kn">from</span> <span class="nn">dolfin</span> <span class="kn">import</span> <span class="o">*</span>
</pre></div>
</div>
<p id="index-0">A class which will be used to represent the initial conditions is then
created:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Class representing the intial conditions</span>
<span class="k">class</span> <span class="nc">InitialConditions</span><span class="p">(</span><span class="n">Expression</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">2</span> <span class="o">+</span> <span class="n">MPI</span><span class="o">.</span><span class="n">rank</span><span class="p">(</span><span class="n">mpi_comm_world</span><span class="p">()))</span>
    <span class="k">def</span> <span class="nf">eval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.63</span> <span class="o">+</span> <span class="mf">0.02</span><span class="o">*</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">-</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">())</span>
        <span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">def</span> <span class="nf">value_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="mi">2</span><span class="p">,)</span>
</pre></div>
</div>
<p>It is a subclass of <a class="reference internal" href="../../../../programmers-reference/functions/expression/Expression.html#dolfin.functions.expression.Expression" title="dolfin.functions.expression.Expression"><code class="xref py py-class docutils literal"><span class="pre">Expression</span></code></a>. In the constructor
(<code class="docutils literal"><span class="pre">__init__</span></code>), the random number generator is seeded. If the program
is run in parallel, the random number generator is seeded using the
rank (process number) to ensure a different sequence of numbers on
each process.  The function <code class="docutils literal"><span class="pre">eval</span></code> returns values for a function of
dimension two.  For the first component of the function, a randomized
value is returned.  The method <code class="docutils literal"><span class="pre">value_shape</span></code> declares that the
<a class="reference internal" href="../../../../programmers-reference/functions/expression/Expression.html#dolfin.functions.expression.Expression" title="dolfin.functions.expression.Expression"><code class="xref py py-class docutils literal"><span class="pre">Expression</span></code></a> is
vector valued with dimension two.</p>
<p id="index-1">A class which will represent the Cahn-Hilliard in an abstract from for
use in the Newton solver is now defined. It is a subclass of
<code class="xref py py-class docutils literal"><span class="pre">NonlinearProblem</span></code>.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Class for interfacing with the Newton solver</span>
<span class="k">class</span> <span class="nc">CahnHilliardEquation</span><span class="p">(</span><span class="n">NonlinearProblem</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">L</span><span class="p">):</span>
        <span class="n">NonlinearProblem</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">L</span> <span class="o">=</span> <span class="n">L</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">a</span>
    <span class="k">def</span> <span class="nf">F</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">assemble</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="n">tensor</span><span class="o">=</span><span class="n">b</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">J</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">assemble</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="n">tensor</span><span class="o">=</span><span class="n">A</span><span class="p">)</span>
</pre></div>
</div>
<p>The constructor (<code class="docutils literal"><span class="pre">__init__</span></code>) stores references to the bilinear
(<code class="docutils literal"><span class="pre">a</span></code>) and linear (<code class="docutils literal"><span class="pre">L</span></code>) forms. These will used to compute the
Jacobian matrix and the residual vector, respectively, for use in a
Newton solver.  The function <code class="docutils literal"><span class="pre">F</span></code> and <code class="docutils literal"><span class="pre">J</span></code> are virtual member
functions of <code class="xref py py-class docutils literal"><span class="pre">NonlinearProblem</span></code>. The function <code class="docutils literal"><span class="pre">F</span></code> computes the
residual vector <code class="docutils literal"><span class="pre">b</span></code>, and the function <code class="docutils literal"><span class="pre">J</span></code> computes the Jacobian
matrix <code class="docutils literal"><span class="pre">A</span></code>.</p>
<p>Next, various model parameters are defined:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Model parameters</span>
<span class="n">lmbda</span>  <span class="o">=</span> <span class="mf">1.0e-02</span>  <span class="c1"># surface parameter</span>
<span class="n">dt</span>     <span class="o">=</span> <span class="mf">5.0e-06</span>  <span class="c1"># time step</span>
<span class="n">theta</span>  <span class="o">=</span> <span class="mf">0.5</span>      <span class="c1"># time stepping family, e.g. theta=1 -&gt; backward Euler, theta=0.5 -&gt; Crank-Nicolson</span>
</pre></div>
</div>
<p id="index-2">It is possible to pass arguments that control aspects of the generated
code to the form compiler. The lines</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Form compiler options</span>
<span class="n">parameters</span><span class="p">[</span><span class="s2">&quot;form_compiler&quot;</span><span class="p">][</span><span class="s2">&quot;optimize&quot;</span><span class="p">]</span>     <span class="o">=</span> <span class="bp">True</span>
<span class="n">parameters</span><span class="p">[</span><span class="s2">&quot;form_compiler&quot;</span><span class="p">][</span><span class="s2">&quot;cpp_optimize&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
</pre></div>
</div>
<p>tell the form to apply optimization strategies in the code generation phase
and the use compiler optimization flags when compiling the generated C++
code. Using the option <code class="docutils literal"><span class="pre">[&quot;optimize&quot;]</span> <span class="pre">=</span> <span class="pre">True</span></code> will generally result in
faster code (sometimes orders of magnitude faster for certain operations,
depending on the equation), but it may take considerably longer to generate
the code and the generation phase may use considerably more memory).</p>
<p>A unit square mesh with 97 (= 96 + 1) vertices in each direction is
created, and on this mesh a <a class="reference internal" href="../../../../programmers-reference/functions/functionspace/FunctionSpace.html#dolfin.functions.functionspace.FunctionSpace" title="dolfin.functions.functionspace.FunctionSpace"><code class="xref py py-class docutils literal"><span class="pre">FunctionSpace</span></code></a> <span class="math">\(V\)</span> and a
<a class="reference internal" href="../../../../programmers-reference/functions/functionspace/MixedFunctionSpace.html#dolfin.functions.functionspace.MixedFunctionSpace" title="dolfin.functions.functionspace.MixedFunctionSpace"><code class="xref py py-class docutils literal"><span class="pre">MixedFunctionSpace</span></code></a> space <span class="math">\(ME =
V \times V\)</span> are defined:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Create mesh and define function spaces</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitSquareMesh</span><span class="p">(</span><span class="mi">96</span><span class="p">,</span> <span class="mi">96</span><span class="p">)</span>
<span class="n">V</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s2">&quot;Lagrange&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">ME</span> <span class="o">=</span> <span class="n">V</span><span class="o">*</span><span class="n">V</span>
</pre></div>
</div>
<p>The space <code class="docutils literal"><span class="pre">V</span></code> involves first-order continuous Lagrange basis functions.
The mixed space is created using the <code class="docutils literal"><span class="pre">*</span></code> operator.</p>
<p>Trial and test functions of the space <code class="docutils literal"><span class="pre">ME</span></code> are now defined:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Define trial and test functions</span>
<span class="n">du</span>    <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">ME</span><span class="p">)</span>
<span class="n">q</span><span class="p">,</span> <span class="n">v</span>  <span class="o">=</span> <span class="n">TestFunctions</span><span class="p">(</span><span class="n">ME</span><span class="p">)</span>
</pre></div>
</div>
<p id="index-3">For the test functions, <a class="reference internal" href="../../../../programmers-reference/functions/function/TestFunctions.html#dolfin.functions.function.TestFunctions" title="dolfin.functions.function.TestFunctions"><code class="xref py py-func docutils literal"><span class="pre">TestFunctions</span></code></a> (note the &#8216;s&#8217; at the end)
is used to define the scalar test functions <code class="docutils literal"><span class="pre">q</span></code> and <code class="docutils literal"><span class="pre">v</span></code>. The
<a class="reference internal" href="../../../../programmers-reference/functions/function/TrialFunction.html#dolfin.functions.function.TrialFunction" title="dolfin.functions.function.TrialFunction"><code class="xref py py-class docutils literal"><span class="pre">TrialFunction</span></code></a>
<code class="docutils literal"><span class="pre">du</span></code> has dimension two. Some mixed objects of the
<a class="reference internal" href="../../../../programmers-reference/functions/function/Function.html#dolfin.functions.function.Function" title="dolfin.functions.function.Function"><code class="xref py py-class docutils literal"><span class="pre">Function</span></code></a> class on
<code class="docutils literal"><span class="pre">ME</span></code> are defined to represent <span class="math">\(u = (c_{n+1}, \mu_{n+1})\)</span> and
<span class="math">\(u0 = (c_{n}, \mu_{n})\)</span>, and these are then split into
sub-functions:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Define functions</span>
<span class="n">u</span>   <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">ME</span><span class="p">)</span>  <span class="c1"># current solution</span>
<span class="n">u0</span>  <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">ME</span><span class="p">)</span>  <span class="c1"># solution from previous converged step</span>

<span class="c1"># Split mixed functions</span>
<span class="n">dc</span><span class="p">,</span> <span class="n">dmu</span> <span class="o">=</span> <span class="n">split</span><span class="p">(</span><span class="n">du</span><span class="p">)</span>
<span class="n">c</span><span class="p">,</span>  <span class="n">mu</span>  <span class="o">=</span> <span class="n">split</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
<span class="n">c0</span><span class="p">,</span> <span class="n">mu0</span> <span class="o">=</span> <span class="n">split</span><span class="p">(</span><span class="n">u0</span><span class="p">)</span>
</pre></div>
</div>
<p>The line <code class="docutils literal"><span class="pre">c,</span> <span class="pre">mu</span> <span class="pre">=</span> <span class="pre">split(u)</span></code> permits direct access to the components
of a mixed function. Note that <code class="docutils literal"><span class="pre">c</span></code> and <code class="docutils literal"><span class="pre">mu</span></code> are references for
components of <code class="docutils literal"><span class="pre">u</span></code>, and not copies.</p>
<p id="index-4">Initial conditions are created by using the class defined at the
beginning of the demo and then interpolating the initial conditions
into a finite element space:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Create intial conditions and interpolate</span>
<span class="n">u_init</span> <span class="o">=</span> <span class="n">InitialConditions</span><span class="p">()</span>
<span class="n">u</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">u_init</span><span class="p">)</span>
<span class="n">u0</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">u_init</span><span class="p">)</span>
</pre></div>
</div>
<p>The first line creates an object of type <code class="docutils literal"><span class="pre">InitialConditions</span></code>.
The following two lines make <code class="docutils literal"><span class="pre">u</span></code> and <code class="docutils literal"><span class="pre">u0</span></code> interpolants of <code class="docutils literal"><span class="pre">u_init</span></code>
(since <code class="docutils literal"><span class="pre">u</span></code> and <code class="docutils literal"><span class="pre">u0</span></code> are finite element functions, they may not be able
to represent a given function exactly, but the function can be approximated
by interpolating it in a finite element space).</p>
<p id="index-5">The chemical potential <span class="math">\(df/dc\)</span> is computed using automated
differentiation:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Compute the chemical potential df/dc</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">variable</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="n">f</span>    <span class="o">=</span> <span class="mi">100</span><span class="o">*</span><span class="n">c</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">c</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
<span class="n">dfdc</span> <span class="o">=</span> <span class="n">diff</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
</pre></div>
</div>
<p>The first line declares that <code class="docutils literal"><span class="pre">c</span></code> is a variable that some function
can be differentiated with respect to. The next line is the function
<span class="math">\(f\)</span> defined in the problem statement, and the third line
performs the differentiation of <code class="docutils literal"><span class="pre">f</span></code> with respect to the variable
<code class="docutils literal"><span class="pre">c</span></code>.</p>
<p>It is convenient to introduce an expression for <span class="math">\(\mu_{n+\theta}\)</span></p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># mu_(n+theta)</span>
<span class="n">mu_mid</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">-</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">mu0</span> <span class="o">+</span> <span class="n">theta</span><span class="o">*</span><span class="n">mu</span>
</pre></div>
</div>
<p>which is then used in the definition of the variational forms:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Weak statement of the equations</span>
<span class="n">L0</span> <span class="o">=</span> <span class="n">c</span><span class="o">*</span><span class="n">q</span><span class="o">*</span><span class="n">dx</span> <span class="o">-</span> <span class="n">c0</span><span class="o">*</span><span class="n">q</span><span class="o">*</span><span class="n">dx</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">mu_mid</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">q</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
<span class="n">L1</span> <span class="o">=</span> <span class="n">mu</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span> <span class="o">-</span> <span class="n">dfdc</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span> <span class="o">-</span> <span class="n">lmbda</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">c</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
<span class="n">L</span> <span class="o">=</span> <span class="n">L0</span> <span class="o">+</span> <span class="n">L1</span>
</pre></div>
</div>
<p>This is a statement of the time-discrete equations presented as part
of the problem statement, using UFL syntax. The linear forms for the
two equations can be summed into one form <code class="docutils literal"><span class="pre">L</span></code>, and then the
directional derivative of <code class="docutils literal"><span class="pre">L</span></code> can be computed to form the bilinear
form which represents the Jacobian matrix:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Compute directional derivative about u in the direction of du (Jacobian)</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">derivative</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">du</span><span class="p">)</span>
</pre></div>
</div>
<p id="index-6">The DOLFIN Newton solver requires a <code class="xref py py-class docutils literal"><span class="pre">NonlinearProblem</span></code> object to solve a system of nonlinear
equations. Here, we are using the class <code class="docutils literal"><span class="pre">CahnHilliardEquation</span></code>,
which was declared at the beginning of the file, and which is a
sub-class of <code class="xref py py-class docutils literal"><span class="pre">NonlinearProblem</span></code>. We need to instantiate objects of both
<code class="docutils literal"><span class="pre">CahnHilliardEquation</span></code> and <code class="xref py py-class docutils literal"><span class="pre">NewtonSolver</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Create nonlinear problem and Newton solver</span>
<span class="n">problem</span> <span class="o">=</span> <span class="n">CahnHilliardEquation</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span>
<span class="n">solver</span> <span class="o">=</span> <span class="n">NewtonSolver</span><span class="p">()</span>
<span class="n">solver</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s2">&quot;linear_solver&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;lu&quot;</span>
<span class="n">solver</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s2">&quot;convergence_criterion&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;incremental&quot;</span>
<span class="n">solver</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s2">&quot;relative_tolerance&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1e-6</span>
</pre></div>
</div>
<p>The string <code class="docutils literal"><span class="pre">&quot;lu&quot;</span></code> passed to the Newton solver indicated that an LU
solver should be used.  The setting of
<code class="docutils literal"><span class="pre">parameters[&quot;convergence_criterion&quot;]</span> <span class="pre">=</span> <span class="pre">&quot;incremental&quot;</span></code> specifies that
the Newton solver should compute a norm of the solution increment to
check for convergence (the other possibility is to use <code class="docutils literal"><span class="pre">&quot;residual&quot;</span></code>,
or to provide a user-defined check). The tolerance for convergence is
specified by <code class="docutils literal"><span class="pre">parameters[&quot;relative_tolerance&quot;]</span> <span class="pre">=</span> <span class="pre">1e-6</span></code>.</p>
<p>To run the solver and save the output to a VTK file for later visualization,
the solver is advanced in time from <span class="math">\(t_{n}\)</span> to <span class="math">\(t_{n+1}\)</span> until
a terminal time <span class="math">\(T\)</span> is reached:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Output file</span>
<span class="nb">file</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="s2">&quot;output.pvd&quot;</span><span class="p">,</span> <span class="s2">&quot;compressed&quot;</span><span class="p">)</span>

<span class="c1"># Step in time</span>
<span class="n">t</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="n">T</span> <span class="o">=</span> <span class="mi">50</span><span class="o">*</span><span class="n">dt</span>
<span class="k">while</span> <span class="p">(</span><span class="n">t</span> <span class="o">&lt;</span> <span class="n">T</span><span class="p">):</span>
    <span class="n">t</span> <span class="o">+=</span> <span class="n">dt</span>
    <span class="n">u0</span><span class="o">.</span><span class="n">vector</span><span class="p">()[:]</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span>
    <span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">problem</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">())</span>
    <span class="nb">file</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">0</span><span class="p">],</span> <span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
<p>The string <code class="docutils literal"><span class="pre">&quot;compressed&quot;</span></code> indicates that the output data should be
compressed to reduce the file size. Within the time stepping loop, the
solution vector associated with <code class="docutils literal"><span class="pre">u</span></code> is copied to <code class="docutils literal"><span class="pre">u0</span></code> at the
beginning of each time step, and the nonlinear problem is solved by
calling <code class="xref py py-func docutils literal"><span class="pre">solver.solve(problem,</span> <span class="pre">u.vector())</span></code>, with the new solution vector
returned in <code class="xref py py-func docutils literal"><span class="pre">u.vector()</span></code>. The
<code class="docutils literal"><span class="pre">c</span></code> component of the solution (the first component of <code class="docutils literal"><span class="pre">u</span></code>) is then
written to file at every time step.</p>
<p>Finally, the last computed solution for <span class="math">\(c\)</span> is plotted to the screen:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">plot</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">interactive</span><span class="p">()</span>
</pre></div>
</div>
<p>The line <code class="docutils literal"><span class="pre">interactive()</span></code> holds the plot (waiting for a keyboard action).</p>
</div>
<div class="section" id="complete-code">
<h2>5.3. Complete code<a class="headerlink" href="#complete-code" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default"><div class="highlight"><pre><span></span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">from</span> <span class="nn">dolfin</span> <span class="k">import</span> <span class="o">*</span>

<span class="c1"># Class representing the intial conditions</span>
<span class="k">class</span> <span class="nc">InitialConditions</span><span class="p">(</span><span class="n">Expression</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">2</span> <span class="o">+</span> <span class="n">MPI</span><span class="o">.</span><span class="n">rank</span><span class="p">(</span><span class="n">mpi_comm_world</span><span class="p">()))</span>
    <span class="k">def</span> <span class="nf">eval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.63</span> <span class="o">+</span> <span class="mf">0.02</span><span class="o">*</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">-</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">())</span>
        <span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">def</span> <span class="nf">value_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="mi">2</span><span class="p">,)</span>

<span class="c1"># Class for interfacing with the Newton solver</span>
<span class="k">class</span> <span class="nc">CahnHilliardEquation</span><span class="p">(</span><span class="n">NonlinearProblem</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">L</span><span class="p">):</span>
        <span class="n">NonlinearProblem</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">L</span> <span class="o">=</span> <span class="n">L</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">a</span>
    <span class="k">def</span> <span class="nf">F</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">assemble</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="n">tensor</span><span class="o">=</span><span class="n">b</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">J</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">assemble</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="n">tensor</span><span class="o">=</span><span class="n">A</span><span class="p">)</span>

<span class="c1"># Model parameters</span>
<span class="n">lmbda</span>  <span class="o">=</span> <span class="mf">1.0e-02</span>  <span class="c1"># surface parameter</span>
<span class="n">dt</span>     <span class="o">=</span> <span class="mf">5.0e-06</span>  <span class="c1"># time step</span>
<span class="n">theta</span>  <span class="o">=</span> <span class="mf">0.5</span>      <span class="c1"># time stepping family, e.g. theta=1 -&gt; backward Euler, theta=0.5 -&gt; Crank-Nicolson</span>

<span class="c1"># Form compiler options</span>
<span class="n">parameters</span><span class="p">[</span><span class="s2">&quot;form_compiler&quot;</span><span class="p">][</span><span class="s2">&quot;optimize&quot;</span><span class="p">]</span>     <span class="o">=</span> <span class="kc">True</span>
<span class="n">parameters</span><span class="p">[</span><span class="s2">&quot;form_compiler&quot;</span><span class="p">][</span><span class="s2">&quot;cpp_optimize&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
<span class="n">parameters</span><span class="p">[</span><span class="s2">&quot;form_compiler&quot;</span><span class="p">][</span><span class="s2">&quot;representation&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;quadrature&quot;</span>

<span class="c1"># Create mesh and define function spaces</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitSquareMesh</span><span class="p">(</span><span class="mi">96</span><span class="p">,</span> <span class="mi">96</span><span class="p">)</span>
<span class="n">V</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s2">&quot;Lagrange&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">ME</span> <span class="o">=</span> <span class="n">V</span><span class="o">*</span><span class="n">V</span>

<span class="c1"># Define trial and test functions</span>
<span class="n">du</span>    <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">ME</span><span class="p">)</span>
<span class="n">q</span><span class="p">,</span> <span class="n">v</span>  <span class="o">=</span> <span class="n">TestFunctions</span><span class="p">(</span><span class="n">ME</span><span class="p">)</span>

<span class="c1"># Define functions</span>
<span class="n">u</span>   <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">ME</span><span class="p">)</span>  <span class="c1"># current solution</span>
<span class="n">u0</span>  <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">ME</span><span class="p">)</span>  <span class="c1"># solution from previous converged step</span>

<span class="c1"># Split mixed functions</span>
<span class="n">dc</span><span class="p">,</span> <span class="n">dmu</span> <span class="o">=</span> <span class="n">split</span><span class="p">(</span><span class="n">du</span><span class="p">)</span>
<span class="n">c</span><span class="p">,</span>  <span class="n">mu</span>  <span class="o">=</span> <span class="n">split</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
<span class="n">c0</span><span class="p">,</span> <span class="n">mu0</span> <span class="o">=</span> <span class="n">split</span><span class="p">(</span><span class="n">u0</span><span class="p">)</span>

<span class="c1"># Create intial conditions and interpolate</span>
<span class="n">u_init</span> <span class="o">=</span> <span class="n">InitialConditions</span><span class="p">()</span>
<span class="n">u</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">u_init</span><span class="p">)</span>
<span class="n">u0</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">u_init</span><span class="p">)</span>

<span class="c1"># Compute the chemical potential df/dc</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">variable</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="n">f</span>    <span class="o">=</span> <span class="mi">100</span><span class="o">*</span><span class="n">c</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">c</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
<span class="n">dfdc</span> <span class="o">=</span> <span class="n">diff</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>

<span class="c1"># mu_(n+theta)</span>
<span class="n">mu_mid</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">-</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">mu0</span> <span class="o">+</span> <span class="n">theta</span><span class="o">*</span><span class="n">mu</span>

<span class="c1"># Weak statement of the equations</span>
<span class="n">L0</span> <span class="o">=</span> <span class="n">c</span><span class="o">*</span><span class="n">q</span><span class="o">*</span><span class="n">dx</span> <span class="o">-</span> <span class="n">c0</span><span class="o">*</span><span class="n">q</span><span class="o">*</span><span class="n">dx</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">mu_mid</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">q</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
<span class="n">L1</span> <span class="o">=</span> <span class="n">mu</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span> <span class="o">-</span> <span class="n">dfdc</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span> <span class="o">-</span> <span class="n">lmbda</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">c</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
<span class="n">L</span> <span class="o">=</span> <span class="n">L0</span> <span class="o">+</span> <span class="n">L1</span>

<span class="c1"># Compute directional derivative about u in the direction of du (Jacobian)</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">derivative</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">du</span><span class="p">)</span>

<span class="c1"># Create nonlinear problem and Newton solver</span>
<span class="n">problem</span> <span class="o">=</span> <span class="n">CahnHilliardEquation</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span>
<span class="n">solver</span> <span class="o">=</span> <span class="n">NewtonSolver</span><span class="p">()</span>
<span class="n">solver</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s2">&quot;linear_solver&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;lu&quot;</span>
<span class="n">solver</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s2">&quot;convergence_criterion&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;incremental&quot;</span>
<span class="n">solver</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s2">&quot;relative_tolerance&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">6</span>

<span class="c1"># Output file</span>
<span class="n">file</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="s2">&quot;output.pvd&quot;</span><span class="p">,</span> <span class="s2">&quot;compressed&quot;</span><span class="p">)</span>

<span class="c1"># Step in time</span>
<span class="n">t</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="n">T</span> <span class="o">=</span> <span class="mi">50</span><span class="o">*</span><span class="n">dt</span>
<span class="k">while</span> <span class="p">(</span><span class="n">t</span> <span class="o">&lt;</span> <span class="n">T</span><span class="p">):</span>
    <span class="n">t</span> <span class="o">+=</span> <span class="n">dt</span>
    <span class="n">u0</span><span class="o">.</span><span class="n">vector</span><span class="p">()[:]</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span>
    <span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">problem</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">())</span>
    <span class="n">file</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">0</span><span class="p">],</span> <span class="n">t</span><span class="p">)</span>

<span class="n">plot</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">interactive</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../../eigenvalue/python/documentation.html" class="btn btn-neutral float-right" title="6. A simple eigenvalue solver" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="../../built-in_meshes/python/documentation.html" class="btn btn-neutral" title="4. Built-in meshes" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright FEniCS Project, https://bitbucket.org/fenics-project/.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../../',
            VERSION:'1.5.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>