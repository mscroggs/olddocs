<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>DOLFIN: dolfin::MultiMesh Class Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DOLFIN
   </div>
   <div id="projectbrief">DOLFIN C++ interface</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="../../annotated.html"><span>Classes</span></a></li>
      <li><a href="../../files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="../../annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="../../classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="../../inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="../../functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../df/de3/namespacedolfin.html">dolfin</a></li><li class="navelem"><a class="el" href="../../da/d83/classdolfin_1_1MultiMesh.html">MultiMesh</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="../../db/de1/classdolfin_1_1MultiMesh-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">dolfin::MultiMesh Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="../../d3/d8d/MultiMesh_8h_source.html">MultiMesh.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for dolfin::MultiMesh:</div>
<div class="dyncontent">
<div class="center"><img src="../../d6/d9e/classdolfin_1_1MultiMesh__inherit__graph.png" border="0" usemap="#dolfin_1_1MultiMesh_inherit__map" alt="Inheritance graph"/></div>
<map name="dolfin_1_1MultiMesh_inherit__map" id="dolfin_1_1MultiMesh_inherit__map">
<area shape="rect" id="node2" href="../../d8/df0/classdolfin_1_1Variable.html" title="Common base class for DOLFIN variables. " alt="" coords="12,5,127,32"/>
</map>
<center><span class="legend">[<a href="../../graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for dolfin::MultiMesh:</div>
<div class="dyncontent">
<div class="center"><img src="../../d8/d34/classdolfin_1_1MultiMesh__coll__graph.png" border="0" usemap="#dolfin_1_1MultiMesh_coll__map" alt="Collaboration graph"/></div>
<map name="dolfin_1_1MultiMesh_coll__map" id="dolfin_1_1MultiMesh_coll__map">
<area shape="rect" id="node2" href="../../d8/df0/classdolfin_1_1Variable.html" title="Common base class for DOLFIN variables. " alt="" coords="17,95,132,121"/>
<area shape="rect" id="node3" href="../../da/d06/classdolfin_1_1Parameters.html" title="dolfin::Parameters" alt="" coords="5,5,144,32"/>
</map>
<center><span class="legend">[<a href="../../graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a8ab8f5d834dac51712e2ac6caba8065c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8ab8f5d834dac51712e2ac6caba8065c"></a>
typedef std::pair&lt; std::vector&lt; double &gt;, std::vector&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d83/classdolfin_1_1MultiMesh.html#a8ab8f5d834dac51712e2ac6caba8065c">quadrature_rule</a></td></tr>
<tr class="memdesc:a8ab8f5d834dac51712e2ac6caba8065c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure storing a quadrature rule. <br /></td></tr>
<tr class="separator:a8ab8f5d834dac51712e2ac6caba8065c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a986ade46e1123ce431d467a1cc5c30d2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a986ade46e1123ce431d467a1cc5c30d2"></a>
typedef std::vector&lt; <a class="el" href="../../d3/d1a/classdolfin_1_1Point.html">Point</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d83/classdolfin_1_1MultiMesh.html#a986ade46e1123ce431d467a1cc5c30d2">Simplex</a></td></tr>
<tr class="memdesc:a986ade46e1123ce431d467a1cc5c30d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simplex is a list of points. <br /></td></tr>
<tr class="separator:a986ade46e1123ce431d467a1cc5c30d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac08a4181e3a0278d5a42a84e29f30ca7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac08a4181e3a0278d5a42a84e29f30ca7"></a>
typedef std::pair&lt; std::vector&lt; <a class="el" href="../../da/d83/classdolfin_1_1MultiMesh.html#a986ade46e1123ce431d467a1cc5c30d2">Simplex</a> &gt;, std::set&lt; std::size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d83/classdolfin_1_1MultiMesh.html#ac08a4181e3a0278d5a42a84e29f30ca7">Polyhedron</a></td></tr>
<tr class="memdesc:ac08a4181e3a0278d5a42a84e29f30ca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">A polyhedron is a list of simplices and the part numbers. <br /></td></tr>
<tr class="separator:ac08a4181e3a0278d5a42a84e29f30ca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a095d67c121719133ad231a1d88c305c5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a095d67c121719133ad231a1d88c305c5"></a>
typedef std::vector&lt; std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d83/classdolfin_1_1MultiMesh.html#a095d67c121719133ad231a1d88c305c5">IncExcKey</a></td></tr>
<tr class="memdesc:a095d67c121719133ad231a1d88c305c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key to identify polyhedra. <br /></td></tr>
<tr class="separator:a095d67c121719133ad231a1d88c305c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9d8ddd998e30be51425b40cc710ec761"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9d8ddd998e30be51425b40cc710ec761"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d83/classdolfin_1_1MultiMesh.html#a9d8ddd998e30be51425b40cc710ec761">MultiMesh</a> ()</td></tr>
<tr class="memdesc:a9d8ddd998e30be51425b40cc710ec761"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create empty multimesh. <br /></td></tr>
<tr class="separator:a9d8ddd998e30be51425b40cc710ec761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2e9166d99c883d62e8eb0431a55bbdb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab2e9166d99c883d62e8eb0431a55bbdb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d83/classdolfin_1_1MultiMesh.html#ab2e9166d99c883d62e8eb0431a55bbdb">MultiMesh</a> (std::vector&lt; std::shared_ptr&lt; const <a class="el" href="../../da/dfc/classdolfin_1_1Mesh.html">Mesh</a> &gt;&gt; meshes, std::size_t quadrature_order)</td></tr>
<tr class="memdesc:ab2e9166d99c883d62e8eb0431a55bbdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create multimesh from given list of meshes. <br /></td></tr>
<tr class="separator:ab2e9166d99c883d62e8eb0431a55bbdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3a75a995a5280a9cfdfd62f936f5e31"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae3a75a995a5280a9cfdfd62f936f5e31"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d83/classdolfin_1_1MultiMesh.html#ae3a75a995a5280a9cfdfd62f936f5e31">MultiMesh</a> (std::shared_ptr&lt; const <a class="el" href="../../da/dfc/classdolfin_1_1Mesh.html">Mesh</a> &gt; mesh_0, std::size_t quadrature_order)</td></tr>
<tr class="memdesc:ae3a75a995a5280a9cfdfd62f936f5e31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create multimesh from one mesh. <br /></td></tr>
<tr class="separator:ae3a75a995a5280a9cfdfd62f936f5e31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1128d50607c04fb13c890608f57bb4e8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1128d50607c04fb13c890608f57bb4e8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d83/classdolfin_1_1MultiMesh.html#a1128d50607c04fb13c890608f57bb4e8">MultiMesh</a> (std::shared_ptr&lt; const <a class="el" href="../../da/dfc/classdolfin_1_1Mesh.html">Mesh</a> &gt; mesh_0, std::shared_ptr&lt; const <a class="el" href="../../da/dfc/classdolfin_1_1Mesh.html">Mesh</a> &gt; mesh_1, std::size_t quadrature_order)</td></tr>
<tr class="memdesc:a1128d50607c04fb13c890608f57bb4e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create multimesh from two meshes. <br /></td></tr>
<tr class="separator:a1128d50607c04fb13c890608f57bb4e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65a0c43a30d592999071c13f6328b2dc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a65a0c43a30d592999071c13f6328b2dc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d83/classdolfin_1_1MultiMesh.html#a65a0c43a30d592999071c13f6328b2dc">MultiMesh</a> (std::shared_ptr&lt; const <a class="el" href="../../da/dfc/classdolfin_1_1Mesh.html">Mesh</a> &gt; mesh_0, std::shared_ptr&lt; const <a class="el" href="../../da/dfc/classdolfin_1_1Mesh.html">Mesh</a> &gt; mesh_1, std::shared_ptr&lt; const <a class="el" href="../../da/dfc/classdolfin_1_1Mesh.html">Mesh</a> &gt; mesh_2, std::size_t quadrature_order)</td></tr>
<tr class="memdesc:a65a0c43a30d592999071c13f6328b2dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create multimesh from three meshes. <br /></td></tr>
<tr class="separator:a65a0c43a30d592999071c13f6328b2dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6104c4d6ef802dff6711258c3b38dcc3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6104c4d6ef802dff6711258c3b38dcc3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d83/classdolfin_1_1MultiMesh.html#a6104c4d6ef802dff6711258c3b38dcc3">~MultiMesh</a> ()</td></tr>
<tr class="memdesc:a6104c4d6ef802dff6711258c3b38dcc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a6104c4d6ef802dff6711258c3b38dcc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04ff018d4de3b86842ec5349266a332b"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d83/classdolfin_1_1MultiMesh.html#a04ff018d4de3b86842ec5349266a332b">num_parts</a> () const </td></tr>
<tr class="separator:a04ff018d4de3b86842ec5349266a332b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4edae9409e5547dff84a3b49a5fada79"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="../../da/dfc/classdolfin_1_1Mesh.html">Mesh</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d83/classdolfin_1_1MultiMesh.html#a4edae9409e5547dff84a3b49a5fada79">part</a> (std::size_t i) const </td></tr>
<tr class="separator:a4edae9409e5547dff84a3b49a5fada79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd7131b60b27a52723199b0ed257454c"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; unsigned int &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d83/classdolfin_1_1MultiMesh.html#abd7131b60b27a52723199b0ed257454c">uncut_cells</a> (std::size_t <a class="el" href="../../da/d83/classdolfin_1_1MultiMesh.html#a4edae9409e5547dff84a3b49a5fada79">part</a>) const </td></tr>
<tr class="separator:abd7131b60b27a52723199b0ed257454c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad13e7d896072bf1b0357098ca8f76a23"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d83/classdolfin_1_1MultiMesh.html#ad13e7d896072bf1b0357098ca8f76a23">cut_cells</a> (std::size_t <a class="el" href="../../da/d83/classdolfin_1_1MultiMesh.html#a4edae9409e5547dff84a3b49a5fada79">part</a>) const </td></tr>
<tr class="separator:ad13e7d896072bf1b0357098ca8f76a23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd54ee1abbd7917f9a3cf401593587f4"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; unsigned int &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d83/classdolfin_1_1MultiMesh.html#abd54ee1abbd7917f9a3cf401593587f4">covered_cells</a> (std::size_t <a class="el" href="../../da/d83/classdolfin_1_1MultiMesh.html#a4edae9409e5547dff84a3b49a5fada79">part</a>) const </td></tr>
<tr class="separator:abd54ee1abbd7917f9a3cf401593587f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a903ae28ce84a028ad78ab77e8e6a4498"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d83/classdolfin_1_1MultiMesh.html#a903ae28ce84a028ad78ab77e8e6a4498">mark_covered</a> (std::size_t <a class="el" href="../../da/d83/classdolfin_1_1MultiMesh.html#a4edae9409e5547dff84a3b49a5fada79">part</a>, const std::vector&lt; unsigned int &gt; &amp;cells)</td></tr>
<tr class="separator:a903ae28ce84a028ad78ab77e8e6a4498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6395c6661fdf6baef9078bbff0334a67"><td class="memItemLeft" align="right" valign="top">const std::map&lt; unsigned int, std::vector&lt; std::pair&lt; std::size_t, unsigned int &gt; &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d83/classdolfin_1_1MultiMesh.html#a6395c6661fdf6baef9078bbff0334a67">collision_map_cut_cells</a> (std::size_t <a class="el" href="../../da/d83/classdolfin_1_1MultiMesh.html#a4edae9409e5547dff84a3b49a5fada79">part</a>) const </td></tr>
<tr class="separator:a6395c6661fdf6baef9078bbff0334a67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a249c8cf74921569f030c9dd166fd2685"><td class="memItemLeft" align="right" valign="top">const std::map&lt; unsigned int, <a class="el" href="../../da/d83/classdolfin_1_1MultiMesh.html#a8ab8f5d834dac51712e2ac6caba8065c">quadrature_rule</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d83/classdolfin_1_1MultiMesh.html#a249c8cf74921569f030c9dd166fd2685">quadrature_rules_cut_cells</a> (std::size_t <a class="el" href="../../da/d83/classdolfin_1_1MultiMesh.html#a4edae9409e5547dff84a3b49a5fada79">part</a>) const </td></tr>
<tr class="separator:a249c8cf74921569f030c9dd166fd2685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9d5c21e5458891e3d9e12520054c9cb"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="../../da/d83/classdolfin_1_1MultiMesh.html#a8ab8f5d834dac51712e2ac6caba8065c">quadrature_rule</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d83/classdolfin_1_1MultiMesh.html#ae9d5c21e5458891e3d9e12520054c9cb">quadrature_rules_cut_cells</a> (std::size_t <a class="el" href="../../da/d83/classdolfin_1_1MultiMesh.html#a4edae9409e5547dff84a3b49a5fada79">part</a>, unsigned int cell_index) const </td></tr>
<tr class="separator:ae9d5c21e5458891e3d9e12520054c9cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af59dc1811fa4306fbb7260fef4f8ef63"><td class="memItemLeft" align="right" valign="top">const std::map&lt; unsigned int, std::vector&lt; <a class="el" href="../../da/d83/classdolfin_1_1MultiMesh.html#a8ab8f5d834dac51712e2ac6caba8065c">quadrature_rule</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d83/classdolfin_1_1MultiMesh.html#af59dc1811fa4306fbb7260fef4f8ef63">quadrature_rules_overlap</a> (std::size_t <a class="el" href="../../da/d83/classdolfin_1_1MultiMesh.html#a4edae9409e5547dff84a3b49a5fada79">part</a>) const </td></tr>
<tr class="separator:af59dc1811fa4306fbb7260fef4f8ef63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a614e7c5bae71878b7f61f87ce5546d75"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="../../da/d83/classdolfin_1_1MultiMesh.html#a8ab8f5d834dac51712e2ac6caba8065c">quadrature_rule</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d83/classdolfin_1_1MultiMesh.html#a614e7c5bae71878b7f61f87ce5546d75">quadrature_rules_overlap</a> (std::size_t <a class="el" href="../../da/d83/classdolfin_1_1MultiMesh.html#a4edae9409e5547dff84a3b49a5fada79">part</a>, unsigned int cell) const </td></tr>
<tr class="separator:a614e7c5bae71878b7f61f87ce5546d75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a164e648a5f6d3b0480ab6d48ff2cfa0e"><td class="memItemLeft" align="right" valign="top">const std::map&lt; unsigned int, std::vector&lt; <a class="el" href="../../da/d83/classdolfin_1_1MultiMesh.html#a8ab8f5d834dac51712e2ac6caba8065c">quadrature_rule</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d83/classdolfin_1_1MultiMesh.html#a164e648a5f6d3b0480ab6d48ff2cfa0e">quadrature_rules_interface</a> (std::size_t <a class="el" href="../../da/d83/classdolfin_1_1MultiMesh.html#a4edae9409e5547dff84a3b49a5fada79">part</a>) const </td></tr>
<tr class="separator:a164e648a5f6d3b0480ab6d48ff2cfa0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7535fb515fc5fdf051e42105191795ea"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="../../da/d83/classdolfin_1_1MultiMesh.html#a8ab8f5d834dac51712e2ac6caba8065c">quadrature_rule</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d83/classdolfin_1_1MultiMesh.html#a7535fb515fc5fdf051e42105191795ea">quadrature_rules_interface</a> (std::size_t <a class="el" href="../../da/d83/classdolfin_1_1MultiMesh.html#a4edae9409e5547dff84a3b49a5fada79">part</a>, unsigned int cell_index) const </td></tr>
<tr class="separator:a7535fb515fc5fdf051e42105191795ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19702e710915cec4e839991532eb2f08"><td class="memItemLeft" align="right" valign="top">const std::map&lt; unsigned int, std::vector&lt; std::vector&lt; double &gt; &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d83/classdolfin_1_1MultiMesh.html#a19702e710915cec4e839991532eb2f08">facet_normals</a> (std::size_t <a class="el" href="../../da/d83/classdolfin_1_1MultiMesh.html#a4edae9409e5547dff84a3b49a5fada79">part</a>) const </td></tr>
<tr class="separator:a19702e710915cec4e839991532eb2f08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a389c9ef509d0bfb9ed09c9597ee9ca47"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="../../dc/dc9/classdolfin_1_1BoundingBoxTree.html">BoundingBoxTree</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d83/classdolfin_1_1MultiMesh.html#a389c9ef509d0bfb9ed09c9597ee9ca47">bounding_box_tree</a> (std::size_t <a class="el" href="../../da/d83/classdolfin_1_1MultiMesh.html#a4edae9409e5547dff84a3b49a5fada79">part</a>) const </td></tr>
<tr class="separator:a389c9ef509d0bfb9ed09c9597ee9ca47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2f2d564691a7ab6d93327c60d7c6440"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="../../dc/dc9/classdolfin_1_1BoundingBoxTree.html">BoundingBoxTree</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d83/classdolfin_1_1MultiMesh.html#ad2f2d564691a7ab6d93327c60d7c6440">bounding_box_tree_boundary</a> (std::size_t <a class="el" href="../../da/d83/classdolfin_1_1MultiMesh.html#a4edae9409e5547dff84a3b49a5fada79">part</a>) const </td></tr>
<tr class="separator:ad2f2d564691a7ab6d93327c60d7c6440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a852f031126c91bcf9caa567cffe3bc86"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d83/classdolfin_1_1MultiMesh.html#a852f031126c91bcf9caa567cffe3bc86">add</a> (std::shared_ptr&lt; const <a class="el" href="../../da/dfc/classdolfin_1_1Mesh.html">Mesh</a> &gt; mesh)</td></tr>
<tr class="separator:a852f031126c91bcf9caa567cffe3bc86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d613b85e74915e74bd80700d5875444"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d613b85e74915e74bd80700d5875444"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d83/classdolfin_1_1MultiMesh.html#a3d613b85e74915e74bd80700d5875444">build</a> (std::size_t quadrature_order=2)</td></tr>
<tr class="memdesc:a3d613b85e74915e74bd80700d5875444"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build multimesh. <br /></td></tr>
<tr class="separator:a3d613b85e74915e74bd80700d5875444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32ca712bece7941d14b89e96d8937469"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a32ca712bece7941d14b89e96d8937469"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d83/classdolfin_1_1MultiMesh.html#a32ca712bece7941d14b89e96d8937469">is_built</a> () const </td></tr>
<tr class="memdesc:a32ca712bece7941d14b89e96d8937469"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether multimesh has been built. <br /></td></tr>
<tr class="separator:a32ca712bece7941d14b89e96d8937469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9a05cb1e6fc27294951d187c4497b79"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af9a05cb1e6fc27294951d187c4497b79"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d83/classdolfin_1_1MultiMesh.html#af9a05cb1e6fc27294951d187c4497b79">clear</a> ()</td></tr>
<tr class="memdesc:af9a05cb1e6fc27294951d187c4497b79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear multimesh. <br /></td></tr>
<tr class="separator:af9a05cb1e6fc27294951d187c4497b79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad856ae09fd0fb65a77d6a0834d839b09"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d83/classdolfin_1_1MultiMesh.html#ad856ae09fd0fb65a77d6a0834d839b09">compute_area</a> () const </td></tr>
<tr class="separator:ad856ae09fd0fb65a77d6a0834d839b09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82fd9b12d2db623e4427d2ff3a6de86f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a82fd9b12d2db623e4427d2ff3a6de86f"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d83/classdolfin_1_1MultiMesh.html#a82fd9b12d2db623e4427d2ff3a6de86f">compute_volume</a> () const </td></tr>
<tr class="memdesc:a82fd9b12d2db623e4427d2ff3a6de86f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Corresponding function for volume. <br /></td></tr>
<tr class="separator:a82fd9b12d2db623e4427d2ff3a6de86f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a191db674a27dec25118076a2e71244c4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a191db674a27dec25118076a2e71244c4"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d83/classdolfin_1_1MultiMesh.html#a191db674a27dec25118076a2e71244c4">plot_matplotlib</a> (double delta_z=1, const std::string &amp;filename=&quot;&quot;) const </td></tr>
<tr class="memdesc:a191db674a27dec25118076a2e71244c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create matplotlib string to plot 2D multimesh (small meshes only) <br /></td></tr>
<tr class="separator:a191db674a27dec25118076a2e71244c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea47aaafd13a769a255be92212e10446"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d83/classdolfin_1_1MultiMesh.html#aea47aaafd13a769a255be92212e10446">auto_cover</a> (std::size_t p, const <a class="el" href="../../d3/d1a/classdolfin_1_1Point.html">Point</a> &amp;point)</td></tr>
<tr class="separator:aea47aaafd13a769a255be92212e10446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classdolfin_1_1Variable"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classdolfin_1_1Variable')"><img src="../../closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="../../d8/df0/classdolfin_1_1Variable.html">dolfin::Variable</a></td></tr>
<tr class="memitem:a5716c9dcafcc8cf59a6f6b5dac3ec7a2 inherit pub_methods_classdolfin_1_1Variable"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5716c9dcafcc8cf59a6f6b5dac3ec7a2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/df0/classdolfin_1_1Variable.html#a5716c9dcafcc8cf59a6f6b5dac3ec7a2">Variable</a> ()</td></tr>
<tr class="memdesc:a5716c9dcafcc8cf59a6f6b5dac3ec7a2 inherit pub_methods_classdolfin_1_1Variable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create unnamed variable. <br /></td></tr>
<tr class="separator:a5716c9dcafcc8cf59a6f6b5dac3ec7a2 inherit pub_methods_classdolfin_1_1Variable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7a982839cdc79a01e24d60910c7d514 inherit pub_methods_classdolfin_1_1Variable"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad7a982839cdc79a01e24d60910c7d514"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/df0/classdolfin_1_1Variable.html#ad7a982839cdc79a01e24d60910c7d514">Variable</a> (const std::string <a class="el" href="../../d8/df0/classdolfin_1_1Variable.html#a2fd6bb6e73e1395948e2b17f6695da72">name</a>, const std::string <a class="el" href="../../d8/df0/classdolfin_1_1Variable.html#a76536780a613e70cc65c824093d9320a">label</a>)</td></tr>
<tr class="memdesc:ad7a982839cdc79a01e24d60910c7d514 inherit pub_methods_classdolfin_1_1Variable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create variable with given name and label. <br /></td></tr>
<tr class="separator:ad7a982839cdc79a01e24d60910c7d514 inherit pub_methods_classdolfin_1_1Variable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5440af581c4cb7bfc71b5919248c3ffe inherit pub_methods_classdolfin_1_1Variable"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5440af581c4cb7bfc71b5919248c3ffe"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/df0/classdolfin_1_1Variable.html#a5440af581c4cb7bfc71b5919248c3ffe">Variable</a> (const <a class="el" href="../../d8/df0/classdolfin_1_1Variable.html">Variable</a> &amp;variable)</td></tr>
<tr class="memdesc:a5440af581c4cb7bfc71b5919248c3ffe inherit pub_methods_classdolfin_1_1Variable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor. <br /></td></tr>
<tr class="separator:a5440af581c4cb7bfc71b5919248c3ffe inherit pub_methods_classdolfin_1_1Variable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfc14d0ad77af53025f890b4d3a7745a inherit pub_methods_classdolfin_1_1Variable"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acfc14d0ad77af53025f890b4d3a7745a"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/df0/classdolfin_1_1Variable.html#acfc14d0ad77af53025f890b4d3a7745a">~Variable</a> ()</td></tr>
<tr class="memdesc:acfc14d0ad77af53025f890b4d3a7745a inherit pub_methods_classdolfin_1_1Variable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:acfc14d0ad77af53025f890b4d3a7745a inherit pub_methods_classdolfin_1_1Variable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a542ce3999098277936f4c305b27cdc1d inherit pub_methods_classdolfin_1_1Variable"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a542ce3999098277936f4c305b27cdc1d"></a>
const <a class="el" href="../../d8/df0/classdolfin_1_1Variable.html">Variable</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/df0/classdolfin_1_1Variable.html#a542ce3999098277936f4c305b27cdc1d">operator=</a> (const <a class="el" href="../../d8/df0/classdolfin_1_1Variable.html">Variable</a> &amp;variable)</td></tr>
<tr class="memdesc:a542ce3999098277936f4c305b27cdc1d inherit pub_methods_classdolfin_1_1Variable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator. <br /></td></tr>
<tr class="separator:a542ce3999098277936f4c305b27cdc1d inherit pub_methods_classdolfin_1_1Variable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a998314e8043c6b47e066c98d2e5818cf inherit pub_methods_classdolfin_1_1Variable"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a998314e8043c6b47e066c98d2e5818cf"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/df0/classdolfin_1_1Variable.html#a998314e8043c6b47e066c98d2e5818cf">rename</a> (const std::string <a class="el" href="../../d8/df0/classdolfin_1_1Variable.html#a2fd6bb6e73e1395948e2b17f6695da72">name</a>, const std::string <a class="el" href="../../d8/df0/classdolfin_1_1Variable.html#a76536780a613e70cc65c824093d9320a">label</a>)</td></tr>
<tr class="memdesc:a998314e8043c6b47e066c98d2e5818cf inherit pub_methods_classdolfin_1_1Variable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rename variable. <br /></td></tr>
<tr class="separator:a998314e8043c6b47e066c98d2e5818cf inherit pub_methods_classdolfin_1_1Variable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fd6bb6e73e1395948e2b17f6695da72 inherit pub_methods_classdolfin_1_1Variable"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2fd6bb6e73e1395948e2b17f6695da72"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/df0/classdolfin_1_1Variable.html#a2fd6bb6e73e1395948e2b17f6695da72">name</a> () const </td></tr>
<tr class="memdesc:a2fd6bb6e73e1395948e2b17f6695da72 inherit pub_methods_classdolfin_1_1Variable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return name. <br /></td></tr>
<tr class="separator:a2fd6bb6e73e1395948e2b17f6695da72 inherit pub_methods_classdolfin_1_1Variable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76536780a613e70cc65c824093d9320a inherit pub_methods_classdolfin_1_1Variable"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a76536780a613e70cc65c824093d9320a"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/df0/classdolfin_1_1Variable.html#a76536780a613e70cc65c824093d9320a">label</a> () const </td></tr>
<tr class="memdesc:a76536780a613e70cc65c824093d9320a inherit pub_methods_classdolfin_1_1Variable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return label (description) <br /></td></tr>
<tr class="separator:a76536780a613e70cc65c824093d9320a inherit pub_methods_classdolfin_1_1Variable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a29eb914a0cb9fdba3c60dba2b47f69 inherit pub_methods_classdolfin_1_1Variable"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/df0/classdolfin_1_1Variable.html#a8a29eb914a0cb9fdba3c60dba2b47f69">id</a> () const </td></tr>
<tr class="separator:a8a29eb914a0cb9fdba3c60dba2b47f69 inherit pub_methods_classdolfin_1_1Variable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a715cc4ad13ff1c19ac56b4238203f77d inherit pub_methods_classdolfin_1_1Variable"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a715cc4ad13ff1c19ac56b4238203f77d"></a>
virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/df0/classdolfin_1_1Variable.html#a715cc4ad13ff1c19ac56b4238203f77d">str</a> (bool verbose) const </td></tr>
<tr class="memdesc:a715cc4ad13ff1c19ac56b4238203f77d inherit pub_methods_classdolfin_1_1Variable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return informal string representation (pretty-print) <br /></td></tr>
<tr class="separator:a715cc4ad13ff1c19ac56b4238203f77d inherit pub_methods_classdolfin_1_1Variable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a649ef6d35a682cfabb3c18e6e7e6babc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a649ef6d35a682cfabb3c18e6e7e6babc"></a>
static <a class="el" href="../../da/d06/classdolfin_1_1Parameters.html">Parameters</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d83/classdolfin_1_1MultiMesh.html#a649ef6d35a682cfabb3c18e6e7e6babc">default_parameters</a> ()</td></tr>
<tr class="memdesc:a649ef6d35a682cfabb3c18e6e7e6babc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default parameter values. <br /></td></tr>
<tr class="separator:a649ef6d35a682cfabb3c18e6e7e6babc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_attribs_classdolfin_1_1Variable"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_classdolfin_1_1Variable')"><img src="../../closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="../../d8/df0/classdolfin_1_1Variable.html">dolfin::Variable</a></td></tr>
<tr class="memitem:a16f758ef3f221f5b46ffa25f1ce999d4 inherit pub_attribs_classdolfin_1_1Variable"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a16f758ef3f221f5b46ffa25f1ce999d4"></a>
<a class="el" href="../../da/d06/classdolfin_1_1Parameters.html">Parameters</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/df0/classdolfin_1_1Variable.html#a16f758ef3f221f5b46ffa25f1ce999d4">parameters</a></td></tr>
<tr class="memdesc:a16f758ef3f221f5b46ffa25f1ce999d4 inherit pub_attribs_classdolfin_1_1Variable"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../da/d06/classdolfin_1_1Parameters.html">Parameters</a>. <br /></td></tr>
<tr class="separator:a16f758ef3f221f5b46ffa25f1ce999d4 inherit pub_attribs_classdolfin_1_1Variable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class represents a collection of meshes with arbitrary overlaps. A multimesh may be created from a set of standard meshes spaces by repeatedly calling <a class="el" href="../../da/d83/classdolfin_1_1MultiMesh.html#a852f031126c91bcf9caa567cffe3bc86">add()</a>, followed by a call to <a class="el" href="../../da/d83/classdolfin_1_1MultiMesh.html#a3d613b85e74915e74bd80700d5875444" title="Build multimesh. ">build()</a>. Note that a multimesh is not useful until <a class="el" href="../../da/d83/classdolfin_1_1MultiMesh.html#a3d613b85e74915e74bd80700d5875444" title="Build multimesh. ">build()</a> has been called. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a852f031126c91bcf9caa567cffe3bc86"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MultiMesh::add </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="../../da/dfc/classdolfin_1_1Mesh.html">Mesh</a> &gt;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add mesh</p>
<p><em>Arguments</em> mesh (<em><a class="el" href="../../da/dfc/classdolfin_1_1Mesh.html">Mesh</a></em>) The mesh </p>

</div>
</div>
<a class="anchor" id="aea47aaafd13a769a255be92212e10446"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MultiMesh::auto_cover </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d3/d1a/classdolfin_1_1Point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Marks all uncut and cut cells connected to the given point as covered. This can be used for instance to mark a hole as covered where one point inside the hole is known. </p>

</div>
</div>
<a class="anchor" id="a389c9ef509d0bfb9ed09c9597ee9ca47"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="../../dc/dc9/classdolfin_1_1BoundingBoxTree.html">BoundingBoxTree</a> &gt; MultiMesh::bounding_box_tree </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>part</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the bounding box tree for the mesh of the given part</p>
<p><em>Arguments</em> part (std::size_t) The part number</p>
<p><em>Returns</em> std::shared_ptr&lt;const BoundingBoxTree&gt; The bounding box tree </p>

</div>
</div>
<a class="anchor" id="ad2f2d564691a7ab6d93327c60d7c6440"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="../../dc/dc9/classdolfin_1_1BoundingBoxTree.html">BoundingBoxTree</a> &gt; MultiMesh::bounding_box_tree_boundary </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>part</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the bounding box tree for the boundary mesh of the given part</p>
<p><em>Arguments</em> part (std::size_t) The part number</p>
<p><em>Returns</em> std::shared_ptr&lt;const BoundingBoxTree&gt; The bounding box tree </p>

</div>
</div>
<a class="anchor" id="a6395c6661fdf6baef9078bbff0334a67"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::map&lt; unsigned int, std::vector&lt; std::pair&lt; std::size_t, unsigned int &gt; &gt; &gt; &amp; MultiMesh::collision_map_cut_cells </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>part</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the collision map for cut cells of the given part</p>
<p><em>Arguments</em> part (std::size_t) The part number</p>
<p><em>Returns</em> std::map&lt;unsigned int, std::vector&lt;std::pair&lt;std::size_t, unsigned int&gt; &gt; &gt; A map from cell indices of cut cells to a list of cutting cells. Each cutting cell is represented as a pair (part_number, cutting_cell_index). </p>

</div>
</div>
<a class="anchor" id="ad856ae09fd0fb65a77d6a0834d839b09"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double MultiMesh::compute_area </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute total interface area or the total volume of multimesh by summing up quadrature weights. If the area or volume of the domain mesh is known, this is a good test to verify that the mesh-mesh intersections and quadrature are correct. </p>

</div>
</div>
<a class="anchor" id="abd54ee1abbd7917f9a3cf401593587f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; unsigned int &gt; &amp; MultiMesh::covered_cells </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>part</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the list of covered cells for given part. The covered cells are defined as all cells that collide with the domain of any part with higher part number, but not with the boundary of that part; in other words cells that are completely covered by any other part (and which therefore are inactive).</p>
<p><em>Arguments</em> part (std::size_t) The part number</p>
<p><em>Returns</em> std::vector&lt;unsigned int&gt; List of covered cell indices for given part </p>

</div>
</div>
<a class="anchor" id="ad13e7d896072bf1b0357098ca8f76a23"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; unsigned int &gt; MultiMesh::cut_cells </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>part</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the list of cut cells for given part. The cut cells are defined as all cells that collide with the boundary of any part with higher part number.</p>
<p>FIXME: Figure out whether this makes sense; a cell may collide with the boundary of part j but may still be covered completely by the domain of part j + 1. Possible solution is to for each part i check overlapping parts starting from the top and working back down to i + 1.</p>
<p><em>Arguments</em> part (std::size_t) The part number</p>
<p><em>Returns</em> std::vector&lt;unsigned int&gt; List of cut cell indices for given part </p>

</div>
</div>
<a class="anchor" id="a19702e710915cec4e839991532eb2f08"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::map&lt; unsigned int, std::vector&lt; std::vector&lt; double &gt; &gt; &gt; &amp; MultiMesh::facet_normals </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>part</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return facet normals for the interface on the given part</p>
<p><em>Arguments</em> part (std::size_t) The part number</p>
<p><em>Returns</em> std::map&lt;unsigned int, std::vector&lt;std::vector&lt;double&gt; &gt; &gt; A map from cell indices of cut cells to facet normals on an interface part cutting through the cell. A separate list of facet normals, one for each quadrature point, is given for each cutting cell and stored in the same order as in the collision map. The facet normals for each set of quadrature points is stored as a contiguous flattened array, the length of which should be equal to the number of quadrature points multiplied by the geometric dimension. Puh! </p>

</div>
</div>
<a class="anchor" id="a903ae28ce84a028ad78ab77e8e6a4498"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MultiMesh::mark_covered </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>cells</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Mark a set of cells as covered in the mesh.</p>
<p><em>Arguments</em> part (std::size_t) The part number cells (std::vector&lt;unsigned int&gt;) The cells to be covered </p>

</div>
</div>
<a class="anchor" id="a04ff018d4de3b86842ec5349266a332b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t MultiMesh::num_parts </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of meshes (parts) of the multimesh</p>
<p><em>Returns</em> std::size_t The number of meshes (parts) of the multimesh. </p>

</div>
</div>
<a class="anchor" id="a4edae9409e5547dff84a3b49a5fada79"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="../../da/dfc/classdolfin_1_1Mesh.html">Mesh</a> &gt; MultiMesh::part </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return mesh (part) number i</p>
<p><em>Arguments</em> i (std::size_t) The part number</p>
<p><em>Returns</em> <em><a class="el" href="../../da/dfc/classdolfin_1_1Mesh.html">Mesh</a></em> <a class="el" href="../../da/dfc/classdolfin_1_1Mesh.html">Mesh</a> (part) number i </p>

</div>
</div>
<a class="anchor" id="a249c8cf74921569f030c9dd166fd2685"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::map&lt; unsigned int, <a class="el" href="../../da/d83/classdolfin_1_1MultiMesh.html#a8ab8f5d834dac51712e2ac6caba8065c">MultiMesh::quadrature_rule</a> &gt; &amp; MultiMesh::quadrature_rules_cut_cells </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>part</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return quadrature rules for cut cells on the given part</p>
<p><em>Arguments</em> part (std::size_t) The part number</p>
<p><em>Returns</em> std::map&lt;unsigned int, std::pair&lt;std::vector&lt;double&gt;, std::vector&lt;double&gt; &gt; &gt; A map from cell indices of cut cells to quadrature rules. Each quadrature rule is represented as a pair of a flattened array of quadrature points and a corresponding array of quadrature weights. </p>

</div>
</div>
<a class="anchor" id="ae9d5c21e5458891e3d9e12520054c9cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../da/d83/classdolfin_1_1MultiMesh.html#a8ab8f5d834dac51712e2ac6caba8065c">MultiMesh::quadrature_rule</a> MultiMesh::quadrature_rules_cut_cells </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cell_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return quadrature rule for a given cut cell on the given part</p>
<p><em>Arguments</em> part (std::size_t) The part number cell (unsigned int) The cell index</p>
<p><em>Returns</em> std::pair&lt;std::vector&lt;double&gt;, std::vector&lt;double&gt; &gt; A quadrature rule represented as a pair of a flattened array of quadrature points and a corresponding array of quadrature weights. An error is raised if the given cell is not in the map. </p>

</div>
</div>
<a class="anchor" id="a164e648a5f6d3b0480ab6d48ff2cfa0e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::map&lt; unsigned int, std::vector&lt; <a class="el" href="../../da/d83/classdolfin_1_1MultiMesh.html#a8ab8f5d834dac51712e2ac6caba8065c">MultiMesh::quadrature_rule</a> &gt; &gt; &amp; MultiMesh::quadrature_rules_interface </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>part</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return quadrature rules for the interface on the given part</p>
<p><em>Arguments</em> part (std::size_t) The part number</p>
<p><em>Returns</em> std::map&lt;unsigned int, std::vector&lt;std::pair&lt;std::vector&lt;double&gt;, std::vector&lt;double&gt; &gt; &gt; &gt; A map from cell indices of cut cells to quadrature rules on an interface part cutting through the cell. A separate quadrature rule is given for each cutting cell and stored in the same order as in the collision map. Each quadrature rule is represented as a pair of an array of quadrature points and a corresponding flattened array of quadrature weights. </p>

</div>
</div>
<a class="anchor" id="a7535fb515fc5fdf051e42105191795ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="../../da/d83/classdolfin_1_1MultiMesh.html#a8ab8f5d834dac51712e2ac6caba8065c">MultiMesh::quadrature_rule</a> &gt; MultiMesh::quadrature_rules_interface </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cell_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return quadrature rules for the interface of a given cut cell on the given part</p>
<p><em>Arguments</em> part (std::size_t) The part number cell (unsigned int) The cell index</p>
<p><em>Returns</em> std::vector&lt;std::pair&lt;std::vector&lt;double&gt;, std::vector&lt;double&gt; &gt; &gt; A vector of quadrature rules on the cut cell. A separate quadrature rule is given for each cutting cell and stored in the same order as in the collision map. Each quadrature rule represented as a pair of a flattened array of quadrature points and a corresponding array of quadrature weights. An error is raised if the given cell is not in the map.</p>
<p>Developer note: this function is mainly useful from Python and could be replaced by a suitable typemap that would make the previous more general function accessible from Python. </p>

</div>
</div>
<a class="anchor" id="af59dc1811fa4306fbb7260fef4f8ef63"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::map&lt; unsigned int, std::vector&lt; <a class="el" href="../../da/d83/classdolfin_1_1MultiMesh.html#a8ab8f5d834dac51712e2ac6caba8065c">MultiMesh::quadrature_rule</a> &gt; &gt; &amp; MultiMesh::quadrature_rules_overlap </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>part</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return quadrature rules for the overlap on the given part.</p>
<p><em>Arguments</em> part (std::size_t) The part number</p>
<p><em>Returns</em> std::map&lt;unsigned int, std::vector&lt;std::pair&lt;std::vector&lt;double&gt;, std::vector&lt;double&gt; &gt; &gt; &gt; A map from cell indices of cut cells to quadrature rules. A separate quadrature rule is given for each cutting cell and stored in the same order as in the collision map. Each quadrature rule is represented as a pair of an array of quadrature points and a corresponding flattened array of quadrature weights. </p>

</div>
</div>
<a class="anchor" id="a614e7c5bae71878b7f61f87ce5546d75"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="../../da/d83/classdolfin_1_1MultiMesh.html#a8ab8f5d834dac51712e2ac6caba8065c">MultiMesh::quadrature_rule</a> &gt; MultiMesh::quadrature_rules_overlap </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cell</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return quadrature rules for the overlap for a given cell on the given part.</p>
<p><em>Arguments</em> part (std::size_t) The part number <em>Returns</em> std::vector&lt;std::pair&lt;std::vector&lt;double&gt;, std::vector&lt;double&gt; &gt; &gt; A vector of quadrature rules on the cut cell. A separate quadrature rule is given for each cutting cell and stored in the same order as in the collision map. A quadrature rule represented as a pair of a flattened array of quadrature points and a corresponding array of quadrature weights. An error is raised if the given cell is not in the map. </p>

</div>
</div>
<a class="anchor" id="abd7131b60b27a52723199b0ed257454c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; unsigned int &gt; &amp; MultiMesh::uncut_cells </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>part</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the list of uncut cells for given part. The uncut cells are defined as all cells that don't collide with any cells in any other part with higher part number.</p>
<p><em>Arguments</em> part (std::size_t) The part number</p>
<p><em>Returns</em> std::vector&lt;unsigned int&gt; List of uncut cell indices for given part </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/fenics/shared/dolfin/mesh/<a class="el" href="../../d3/d8d/MultiMesh_8h_source.html">MultiMesh.h</a></li>
<li>/home/fenics/shared/dolfin/mesh/MultiMesh.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
