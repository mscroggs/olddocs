

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Tensor-weighted Poisson &mdash; DOLFIN  documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> DOLFIN
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../using.html">Using DOLFIN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../demos.html">Demos</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api.html">Python API reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developer.html">Developer resources</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contributing.html">Contributing</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">DOLFIN</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
      <li>Tensor-weighted Poisson</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/demos/tensor-weighted-poisson/documentation.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="tensor-weighted-poisson">
<span id="demo-pde-tensor-weighted-poisson-python-documentation"></span><h1>Tensor-weighted Poisson<a class="headerlink" href="#tensor-weighted-poisson" title="Permalink to this headline">¶</a></h1>
<p>This demo is implemented in two files; one file,
<a class="reference download internal" href="../../_downloads/generate_data.py" download=""><code class="xref download docutils literal notranslate"><span class="pre">generate_data.py</span></code></a> , for generating data, and one file,
<a class="reference download internal" href="../../_downloads/demo_tensor-weighted-poisson.py" download=""><code class="xref download docutils literal notranslate"><span class="pre">demo_tensor-weighted-poisson.py</span></code></a> , which contains both the
vaiational form and the solver.</p>
<div class="section" id="implementation">
<h2>Implementation<a class="headerlink" href="#implementation" title="Permalink to this headline">¶</a></h2>
<div class="section" id="implementation-of-generate-data-py">
<h3>Implementation of generate_data.py<a class="headerlink" href="#implementation-of-generate-data-py" title="Permalink to this headline">¶</a></h3>
<p>First, the <code class="xref py py-mod docutils literal notranslate"><span class="pre">dolfin</span></code> module is imported:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">dolfin</span> <span class="kn">import</span> <span class="o">*</span>
</pre></div>
</div>
<p>Then, we define a mesh of the domain. We use the built-in mesh,
provided by the class <code class="xref py py-class docutils literal notranslate"><span class="pre">UnitSquareMesh</span></code>. In order to create a mesh
consisting of <span class="math notranslate nohighlight">\(32 \times 32\)</span> squares with each square divided
into two triangles, we do as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create mesh</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitSquareMesh</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>
</pre></div>
</div>
<p>Now, we create mesh functions to store the values of the conductivity
matrix as it varies over the domain.  Since the matrix is symmetric,
we only create mesh functions for the upper triangular part of the
matrix. In <code class="xref py py-class docutils literal notranslate"><span class="pre">MeshFunction</span></code>
the first argument specifies the type of the mesh function, here we
use “double”.  Other types allowed are “int”, “size_t” and “bool”.
The two following arguments are optional; the first gives the mesh the
<code class="xref py py-class docutils literal notranslate"><span class="pre">MeshFunction</span></code> is defined on,
and the second the topological dimension of the mesh function.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create mesh functions for c00, c01, c11</span>
<span class="n">c00</span> <span class="o">=</span> <span class="n">MeshFunction</span><span class="p">(</span><span class="s2">&quot;double&quot;</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">c01</span> <span class="o">=</span> <span class="n">MeshFunction</span><span class="p">(</span><span class="s2">&quot;double&quot;</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">c11</span> <span class="o">=</span> <span class="n">MeshFunction</span><span class="p">(</span><span class="s2">&quot;double&quot;</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>To set the values of the mesh functions, we go through all the cells
in the mesh and check whether the midpoint value of the cell in the
<span class="math notranslate nohighlight">\(x\)</span>-direction is less than 0.5 or not (in practice this means
that we are checking which half of the unit square the cell is
in). Then we set the correct values of the mesh functions, depending
on which half we are in.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Iterate over mesh and set values</span>
<span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">cells</span><span class="p">(</span><span class="n">mesh</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">cell</span><span class="o">.</span><span class="n">midpoint</span><span class="p">()</span><span class="o">.</span><span class="n">x</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">0.5</span><span class="p">:</span>
        <span class="n">c00</span><span class="p">[</span><span class="n">cell</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="n">c01</span><span class="p">[</span><span class="n">cell</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.3</span>
        <span class="n">c11</span><span class="p">[</span><span class="n">cell</span><span class="p">]</span> <span class="o">=</span> <span class="mf">2.0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">c00</span><span class="p">[</span><span class="n">cell</span><span class="p">]</span> <span class="o">=</span> <span class="mf">3.0</span>
        <span class="n">c01</span><span class="p">[</span><span class="n">cell</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span>
        <span class="n">c11</span><span class="p">[</span><span class="n">cell</span><span class="p">]</span> <span class="o">=</span> <span class="mf">4.0</span>
</pre></div>
</div>
<p>Create files to store data and save to file:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Store to file</span>
<span class="n">mesh_file</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="s2">&quot;../unitsquare_32_32.xml.gz&quot;</span><span class="p">)</span>
<span class="n">c00_file</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="s2">&quot;../unitsquare_32_32_c00.xml.gz&quot;</span><span class="p">)</span>
<span class="n">c01_file</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="s2">&quot;../unitsquare_32_32_c01.xml.gz&quot;</span><span class="p">)</span>
<span class="n">c11_file</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="s2">&quot;../unitsquare_32_32_c11.xml.gz&quot;</span><span class="p">)</span>

<span class="n">mesh_file</span> <span class="o">&lt;&lt;</span> <span class="n">mesh</span>
<span class="n">c00_file</span> <span class="o">&lt;&lt;</span> <span class="n">c00</span>
<span class="n">c01_file</span> <span class="o">&lt;&lt;</span> <span class="n">c01</span>
<span class="n">c11_file</span> <span class="o">&lt;&lt;</span> <span class="n">c11</span>
</pre></div>
</div>
<p>Plot the mesh functions using the <code class="docutils literal notranslate"><span class="pre">plot</span></code> function:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Plot mesh functions</span>
<span class="n">plot</span><span class="p">(</span><span class="n">c00</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s2">&quot;C00&quot;</span><span class="p">)</span>
<span class="n">plot</span><span class="p">(</span><span class="n">c01</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s2">&quot;C01&quot;</span><span class="p">)</span>
<span class="n">plot</span><span class="p">(</span><span class="n">c11</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s2">&quot;C11&quot;</span><span class="p">)</span>

<span class="n">interactive</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="implementation-of-tensor-weighted-poisson-py">
<h3>Implementation of tensor-weighted-poisson.py<a class="headerlink" href="#implementation-of-tensor-weighted-poisson-py" title="Permalink to this headline">¶</a></h3>
<p>This description goes through the implementation (in
<a class="reference download internal" href="../../_downloads/demo_tensor-weighted-poisson.py" download=""><code class="xref download docutils literal notranslate"><span class="pre">demo_tensor-weighted-poisson.py</span></code></a> ) of a solver for the above
described Poisson equation step-by-step.</p>
<p>First, the <code class="xref py py-mod docutils literal notranslate"><span class="pre">dolfin</span></code> module is imported:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">dolfin</span> <span class="kn">import</span> <span class="o">*</span>
</pre></div>
</div>
<p>We proceed by defining a mesh of the domain and a finite element
function space <span class="math notranslate nohighlight">\(V\)</span> relative to this mesh. We read the mesh file
generated by <a class="reference download internal" href="../../_downloads/generate_data.py" download=""><code class="xref download docutils literal notranslate"><span class="pre">generate_data.py</span></code></a> and create the function
space in the following way:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Read mesh from file and create function space</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">Mesh</span><span class="p">(</span><span class="s2">&quot;../unitsquare_32_32.xml.gz&quot;</span><span class="p">)</span>
<span class="n">V</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s2">&quot;Lagrange&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>The second argument to <a class="reference internal" href="../../_autogenerated/dolfin.cpp.function.html#dolfin.cpp.function.FunctionSpace" title="dolfin.cpp.function.FunctionSpace"><code class="xref py py-class docutils literal notranslate"><span class="pre">FunctionSpace</span></code></a> is the finite element family,
while the third argument specifies the polynomial degree.  Thus, in
this case, our space <code class="docutils literal notranslate"><span class="pre">V</span></code> consists of first-order, continuous
Lagrange finite element functions (or in order words, continuous
piecewise linear polynomials).</p>
<p>Next, we want to consider the Dirichlet boundary condition.  A simple
Python function, returning a boolean, can be used to define the
subdomain for the Dirichlet boundary condition (<span class="math notranslate nohighlight">\(\Gamma_D\)</span>).
The function should return True for those points inside the subdomain
and False for the points outside.  In our case, we want to say that
the points <span class="math notranslate nohighlight">\((x, y)\)</span> such that <span class="math notranslate nohighlight">\(x = 0\)</span> or <span class="math notranslate nohighlight">\(x = 1\)</span> are
inside on the inside of <span class="math notranslate nohighlight">\(\Gamma_D\)</span>.  (Note that because of
rounding-off errors, it is often wise to instead specify <span class="math notranslate nohighlight">\(x &lt;
\epsilon\)</span> or <span class="math notranslate nohighlight">\(x &gt; 1 - \epsilon\)</span> where <span class="math notranslate nohighlight">\(\epsilon\)</span> is a
small number (such as machine precision).)</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Define Dirichlet boundary (x = 0 or x = 1)</span>
<span class="k">def</span> <span class="nf">boundary</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">DOLFIN_EPS</span> <span class="ow">or</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">DOLFIN_EPS</span>
</pre></div>
</div>
<p>Now, the Dirichlet boundary condition can be created using the class
<a class="reference internal" href="../../_autogenerated/dolfin.cpp.fem.html#dolfin.cpp.fem.DirichletBC" title="dolfin.cpp.fem.DirichletBC"><code class="xref py py-class docutils literal notranslate"><span class="pre">DirichletBC</span></code></a>.  A
<a class="reference internal" href="../../_autogenerated/dolfin.cpp.fem.html#dolfin.cpp.fem.DirichletBC" title="dolfin.cpp.fem.DirichletBC"><code class="xref py py-class docutils literal notranslate"><span class="pre">DirichletBC</span></code></a> takes three
arguments: the function space the boundary condition applies to, the
value of the boundary condition, and the part of the boundary on which
the condition applies.  In our example, the function space is
<span class="math notranslate nohighlight">\(V\)</span>. The value of the boundary condition <span class="math notranslate nohighlight">\((0.0)\)</span> can be
represented using a <code class="xref py py-class docutils literal notranslate"><span class="pre">Constant</span></code> and the Dirichlet boundary is
defined immediately above. The definition of the Dirichlet boundary
condition then looks as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Define boundary condition</span>
<span class="n">u0</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>
<span class="n">bc</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">u0</span><span class="p">,</span> <span class="n">boundary</span><span class="p">)</span>
</pre></div>
</div>
<p>Before we define the conductivity matrix, we create a string
containing C++ code for evaluation of the conductivity. Later we will
use this string when we create an <a class="reference internal" href="../../_autogenerated/dolfin.cpp.function.html#dolfin.cpp.function.Expression" title="dolfin.cpp.function.Expression"><code class="xref py py-class docutils literal notranslate"><span class="pre">Expression</span></code></a> containing the entries of the
matrix.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Code for C++ evaluation of conductivity</span>
<span class="n">conductivity_code</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>

<span class="s2">class Conductivity : public Expression</span>
<span class="s2">{</span>
<span class="s2">public:</span>

<span class="s2">  // Create expression with 3 components</span>
<span class="s2">  Conductivity() : Expression(3) {}</span>

<span class="s2">  // Function for evaluating expression on each cell</span>
<span class="s2">  void eval(Array&lt;double&gt;&amp; values, const Array&lt;double&gt;&amp; x, const ufc::cell&amp; cell) const</span>
<span class="s2">  {</span>
<span class="s2">    const uint D = cell.topological_dimension;</span>
<span class="s2">    const uint cell_index = cell.index;</span>
<span class="s2">    values[0] = (*c00)[cell_index];</span>
<span class="s2">    values[1] = (*c01)[cell_index];</span>
<span class="s2">    values[2] = (*c11)[cell_index];</span>
<span class="s2">  }</span>

<span class="s2">  // The data stored in mesh functions</span>
<span class="s2">  std::shared_ptr&lt;MeshFunction&lt;double&gt; &gt; c00;</span>
<span class="s2">  std::shared_ptr&lt;MeshFunction&lt;double&gt; &gt; c01;</span>
<span class="s2">  std::shared_ptr&lt;MeshFunction&lt;double&gt; &gt; c11;</span>

<span class="s2">};</span>
<span class="s2">&quot;&quot;&quot;</span>
</pre></div>
</div>
<p>We define the conductivity matrix by first creating mesh functions
from the files we stored in <a class="reference download internal" href="../../_downloads/generate_data.py" download=""><code class="xref download docutils literal notranslate"><span class="pre">generate_data.py</span></code></a>.  Here, the
third argument in <code class="xref py py-class docutils literal notranslate"><span class="pre">MeshFunction</span></code> is the path to the data files.  Then,
we define an expression for the entries in the matrix where we give
the C++ code as an argument for optimalization. Finally, we use the
UFL function <code class="docutils literal notranslate"><span class="pre">as_matrix</span></code> to create the matrix consisting of the
expressions.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Define conductivity expression and matrix</span>
<span class="n">c00</span> <span class="o">=</span> <span class="n">MeshFunction</span><span class="p">(</span><span class="s2">&quot;double&quot;</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="s2">&quot;../unitsquare_32_32_c00.xml.gz&quot;</span><span class="p">)</span>
<span class="n">c01</span> <span class="o">=</span> <span class="n">MeshFunction</span><span class="p">(</span><span class="s2">&quot;double&quot;</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="s2">&quot;../unitsquare_32_32_c01.xml.gz&quot;</span><span class="p">)</span>
<span class="n">c11</span> <span class="o">=</span> <span class="n">MeshFunction</span><span class="p">(</span><span class="s2">&quot;double&quot;</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="s2">&quot;../unitsquare_32_32_c11.xml.gz&quot;</span><span class="p">)</span>

<span class="n">c</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="n">cppcode</span><span class="o">=</span><span class="n">conductivity_code</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">c</span><span class="o">.</span><span class="n">c00</span> <span class="o">=</span> <span class="n">c00</span>
<span class="n">c</span><span class="o">.</span><span class="n">c01</span> <span class="o">=</span> <span class="n">c01</span>
<span class="n">c</span><span class="o">.</span><span class="n">c11</span> <span class="o">=</span> <span class="n">c11</span>
<span class="n">C</span> <span class="o">=</span> <span class="n">as_matrix</span><span class="p">(((</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="mi">2</span><span class="p">])))</span>
</pre></div>
</div>
<p>Next, we want to express the variational problem. First, we need to
specify the trial function <span class="math notranslate nohighlight">\(u\)</span> and the test function <span class="math notranslate nohighlight">\(v\)</span>,
both living in the function space <span class="math notranslate nohighlight">\(V\)</span>.  We do this by defining a
<code class="xref py py-func docutils literal notranslate"><span class="pre">TrialFunction</span></code> and
a <code class="xref py py-func docutils literal notranslate"><span class="pre">TestFunction</span></code> on
the previously defined <a class="reference internal" href="../../_autogenerated/dolfin.cpp.function.html#dolfin.cpp.function.FunctionSpace" title="dolfin.cpp.function.FunctionSpace"><code class="xref py py-class docutils literal notranslate"><span class="pre">FunctionSpace</span></code></a> <span class="math notranslate nohighlight">\(V\)</span>.</p>
<p>Further, the source <span class="math notranslate nohighlight">\(f\)</span> is involved in the variational form, and
hence it must be must specified.  Since <span class="math notranslate nohighlight">\(f\)</span> is given by a simple
mathematical formula, it can easily be declared using the
<a class="reference internal" href="../../_autogenerated/dolfin.cpp.function.html#dolfin.cpp.function.Expression" title="dolfin.cpp.function.Expression"><code class="xref py py-class docutils literal notranslate"><span class="pre">Expression</span></code></a> class.  Note
that the string defining <span class="math notranslate nohighlight">\(f\)</span> uses C++ syntax since, for
efficiency, DOLFIN will generate and compile C++ code for these
expressions at run-time.</p>
<p>With these ingredients, we can write down the bilinear form <span class="math notranslate nohighlight">\(a\)</span>
and the linear form <span class="math notranslate nohighlight">\(L\)</span> (using UFL operators).  In summary, this
reads:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Define variational problem</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s2">&quot;10*exp(-(pow(x[0] - 0.5, 2) + pow(x[1] - 0.5, 2)) / 0.02)&quot;</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">C</span><span class="o">*</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
<span class="n">L</span> <span class="o">=</span> <span class="n">f</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span>
</pre></div>
</div>
<p>Now, we have specified the bilinear and linear forms and can consider
the solution of the variational problem.  First, we need to define a
<a class="reference internal" href="../../_autogenerated/dolfin.cpp.function.html#dolfin.cpp.function.Function" title="dolfin.cpp.function.Function"><code class="xref py py-class docutils literal notranslate"><span class="pre">Function</span></code></a> <code class="docutils literal notranslate"><span class="pre">u</span></code> to
represent the solution. (Upon initialization, it is simply set to the
zero function.) A <a class="reference internal" href="../../_autogenerated/dolfin.cpp.function.html#dolfin.cpp.function.Function" title="dolfin.cpp.function.Function"><code class="xref py py-class docutils literal notranslate"><span class="pre">Function</span></code></a>
represents a function living in a finite element function space.
Next, we can call the <code class="xref py py-meth docutils literal notranslate"><span class="pre">solve</span></code> function with
the arguments <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">==</span> <span class="pre">L</span></code>, <code class="docutils literal notranslate"><span class="pre">u</span></code> and <code class="docutils literal notranslate"><span class="pre">bc</span></code> as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Compute solution</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">solve</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">L</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bc</span><span class="p">)</span>
</pre></div>
</div>
<p>The function <code class="docutils literal notranslate"><span class="pre">u</span></code> will be modified during the call to solve. The
default settings for solving a variational problem have been used.
However, the solution process can be controlled in much more detail if
desired.</p>
<p>A <a class="reference internal" href="../../_autogenerated/dolfin.cpp.function.html#dolfin.cpp.function.Function" title="dolfin.cpp.function.Function"><code class="xref py py-class docutils literal notranslate"><span class="pre">Function</span></code></a> can be
manipulated in various ways, in particular, it can be plotted and
saved to file. Here, we output the solution to a VTK file (using the
suffix .pvd) for later visualization and also plot it using the
<code class="xref py py-meth docutils literal notranslate"><span class="pre">plot</span></code> command:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Save solution in VTK format</span>
<span class="nb">file</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="s2">&quot;poisson.pvd&quot;</span><span class="p">)</span>
<span class="nb">file</span> <span class="o">&lt;&lt;</span> <span class="n">u</span>

<span class="c1"># Plot solution</span>
<span class="n">plot</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">interactive</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="complete-code">
<h2>Complete code<a class="headerlink" href="#complete-code" title="Permalink to this headline">¶</a></h2>
<p>demo_tensor-weighted-poisson.py:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>
<span class="kn">from</span> <span class="nn">dolfin</span> <span class="k">import</span> <span class="o">*</span>

<span class="c1"># Read mesh from file and create function space</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">Mesh</span><span class="p">(</span><span class="s2">&quot;../unitsquare_32_32.xml.gz&quot;</span><span class="p">)</span>
<span class="n">V</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s2">&quot;Lagrange&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="c1"># Define Dirichlet boundary (x = 0 or x = 1)</span>
<span class="k">def</span> <span class="nf">boundary</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">DOLFIN_EPS</span> <span class="ow">or</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">DOLFIN_EPS</span>

<span class="c1"># Define boundary condition</span>
<span class="n">u0</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>
<span class="n">bc</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">u0</span><span class="p">,</span> <span class="n">boundary</span><span class="p">)</span>

<span class="c1"># Define conductivity components as MeshFunctions</span>
<span class="n">c00</span> <span class="o">=</span> <span class="n">MeshFunction</span><span class="p">(</span><span class="s2">&quot;double&quot;</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="s2">&quot;../unitsquare_32_32_c00.xml.gz&quot;</span><span class="p">)</span>
<span class="n">c01</span> <span class="o">=</span> <span class="n">MeshFunction</span><span class="p">(</span><span class="s2">&quot;double&quot;</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="s2">&quot;../unitsquare_32_32_c01.xml.gz&quot;</span><span class="p">)</span>
<span class="n">c11</span> <span class="o">=</span> <span class="n">MeshFunction</span><span class="p">(</span><span class="s2">&quot;double&quot;</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="s2">&quot;../unitsquare_32_32_c11.xml.gz&quot;</span><span class="p">)</span>

<span class="c1"># Code for C++ evaluation of conductivity</span>
<span class="n">conductivity_code</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>

<span class="s2">#include &lt;pybind11/pybind11.h&gt;</span>
<span class="s2">#include &lt;pybind11/eigen.h&gt;</span>
<span class="s2">namespace py = pybind11;</span>

<span class="s2">#include &lt;dolfin/function/Expression.h&gt;</span>
<span class="s2">#include &lt;dolfin/mesh/MeshFunction.h&gt;</span>

<span class="s2">class Conductivity : public dolfin::Expression</span>
<span class="s2">{</span>
<span class="s2">public:</span>

<span class="s2">  // Create expression with 3 components</span>
<span class="s2">  Conductivity() : dolfin::Expression(3) </span><span class="si">{}</span><span class="s2"></span>

<span class="s2">  // Function for evaluating expression on each cell</span>
<span class="s2">  void eval(Eigen::Ref&lt;Eigen::VectorXd&gt; values, Eigen::Ref&lt;const Eigen::VectorXd&gt; x, const ufc::cell&amp; cell) const override</span>
<span class="s2">  {</span>
<span class="s2">    const uint cell_index = cell.index;</span>
<span class="s2">    values[0] = (*c00)[cell_index];</span>
<span class="s2">    values[1] = (*c01)[cell_index];</span>
<span class="s2">    values[2] = (*c11)[cell_index];</span>
<span class="s2">  }</span>

<span class="s2">  // The data stored in mesh functions</span>
<span class="s2">  std::shared_ptr&lt;dolfin::MeshFunction&lt;double&gt;&gt; c00;</span>
<span class="s2">  std::shared_ptr&lt;dolfin::MeshFunction&lt;double&gt;&gt; c01;</span>
<span class="s2">  std::shared_ptr&lt;dolfin::MeshFunction&lt;double&gt;&gt; c11;</span>

<span class="s2">};</span>

<span class="s2">PYBIND11_MODULE(SIGNATURE, m)</span>
<span class="s2">{</span>
<span class="s2">  py::class_&lt;Conductivity, std::shared_ptr&lt;Conductivity&gt;, dolfin::Expression&gt;</span>
<span class="s2">    (m, &quot;Conductivity&quot;)</span>
<span class="s2">    .def(py::init&lt;&gt;())</span>
<span class="s2">    .def_readwrite(&quot;c00&quot;, &amp;Conductivity::c00)</span>
<span class="s2">    .def_readwrite(&quot;c01&quot;, &amp;Conductivity::c01)</span>
<span class="s2">    .def_readwrite(&quot;c11&quot;, &amp;Conductivity::c11);</span>
<span class="s2">}</span>

<span class="s2">&quot;&quot;&quot;</span>

<span class="n">c</span> <span class="o">=</span> <span class="n">CompiledExpression</span><span class="p">(</span><span class="n">compile_cpp_code</span><span class="p">(</span><span class="n">conductivity_code</span><span class="p">)</span><span class="o">.</span><span class="n">Conductivity</span><span class="p">(),</span>
                       <span class="n">c00</span><span class="o">=</span><span class="n">c00</span><span class="p">,</span> <span class="n">c01</span><span class="o">=</span><span class="n">c01</span><span class="p">,</span> <span class="n">c11</span><span class="o">=</span><span class="n">c11</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="n">C</span> <span class="o">=</span> <span class="n">as_matrix</span><span class="p">(((</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="mi">2</span><span class="p">])))</span>

<span class="c1"># Define variational problem</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s2">&quot;10*exp(-(pow(x[0] - 0.5, 2) + pow(x[1] - 0.5, 2)) / 0.02)&quot;</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">C</span><span class="o">*</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
<span class="n">L</span> <span class="o">=</span> <span class="n">f</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span>

<span class="c1"># Compute solution</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">solve</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">L</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bc</span><span class="p">)</span>

<span class="c1"># Save solution in VTK format</span>
<span class="n">file</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="s2">&quot;poisson.pvd&quot;</span><span class="p">)</span>
<span class="n">file</span> <span class="o">&lt;&lt;</span> <span class="n">u</span>

<span class="c1"># Plot solution</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="n">plot</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>generate_data.py:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>
<span class="kn">from</span> <span class="nn">dolfin</span> <span class="k">import</span> <span class="o">*</span>

<span class="c1"># Create mesh</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitSquareMesh</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>

<span class="c1"># Create mesh functions for c00, c01, c11</span>
<span class="n">c00</span> <span class="o">=</span> <span class="n">MeshFunction</span><span class="p">(</span><span class="s2">&quot;double&quot;</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">c01</span> <span class="o">=</span> <span class="n">MeshFunction</span><span class="p">(</span><span class="s2">&quot;double&quot;</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">c11</span> <span class="o">=</span> <span class="n">MeshFunction</span><span class="p">(</span><span class="s2">&quot;double&quot;</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

<span class="c1"># Iterate over mesh and set values</span>
<span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">cells</span><span class="p">(</span><span class="n">mesh</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">cell</span><span class="o">.</span><span class="n">midpoint</span><span class="p">()</span><span class="o">.</span><span class="n">x</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">0.5</span><span class="p">:</span>
        <span class="n">c00</span><span class="p">[</span><span class="n">cell</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="n">c01</span><span class="p">[</span><span class="n">cell</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.3</span>
        <span class="n">c11</span><span class="p">[</span><span class="n">cell</span><span class="p">]</span> <span class="o">=</span> <span class="mf">2.0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">c00</span><span class="p">[</span><span class="n">cell</span><span class="p">]</span> <span class="o">=</span> <span class="mf">3.0</span>
        <span class="n">c01</span><span class="p">[</span><span class="n">cell</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span>
        <span class="n">c11</span><span class="p">[</span><span class="n">cell</span><span class="p">]</span> <span class="o">=</span> <span class="mf">4.0</span>

<span class="c1"># Store to file</span>
<span class="n">mesh_file</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="s2">&quot;../unitsquare_32_32.xml.gz&quot;</span><span class="p">)</span>
<span class="n">c00_file</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="s2">&quot;../unitsquare_32_32_c00.xml.gz&quot;</span><span class="p">)</span>
<span class="n">c01_file</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="s2">&quot;../unitsquare_32_32_c01.xml.gz&quot;</span><span class="p">)</span>
<span class="n">c11_file</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="s2">&quot;../unitsquare_32_32_c11.xml.gz&quot;</span><span class="p">)</span>

<span class="n">mesh_file</span> <span class="o">&lt;&lt;</span> <span class="n">mesh</span>
<span class="n">c00_file</span> <span class="o">&lt;&lt;</span> <span class="n">c00</span>
<span class="n">c01_file</span> <span class="o">&lt;&lt;</span> <span class="n">c01</span>
<span class="n">c11_file</span> <span class="o">&lt;&lt;</span> <span class="n">c11</span>

<span class="c1"># Plot mesh functions</span>
<span class="n">plot</span><span class="p">(</span><span class="n">c00</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s2">&quot;C00&quot;</span><span class="p">,</span> <span class="n">interactive</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">plot</span><span class="p">(</span><span class="n">c01</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s2">&quot;C01&quot;</span><span class="p">,</span> <span class="n">interactive</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">plot</span><span class="p">(</span><span class="n">c11</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s2">&quot;C11&quot;</span><span class="p">,</span> <span class="n">interactive</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, FEniCS Project.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  <script type="text/javascript" src="../../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>