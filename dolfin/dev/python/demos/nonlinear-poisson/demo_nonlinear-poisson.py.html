

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Nonlinear Poisson equation &mdash; DOLFIN  documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Singular Poisson" href="../singular-poisson/demo_singular-poisson.py.html" />
    <link rel="prev" title="Hyperelasticity" href="../hyperelasticity/demo_hyperelasticity.py.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home" alt="Documentation Home"> DOLFIN
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../using.html">Using DOLFIN</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../demos.html">Demos</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../../demos.html#introductory-demos">Introductory demos</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../demos.html#more-advanced-demos">More advanced demos</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../../demos.html#all-documented-demos">All documented demos</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../poisson/demo_poisson.py.html">Poisson equation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../eigenvalue/demo_eigenvalue.py.html">A simple eigenvalue solver</a></li>
<li class="toctree-l3"><a class="reference internal" href="../built-in-meshes/demo_built-in-meshes.py.html">Built-in meshes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../mixed-poisson/demo_mixed-poisson.py.html">Mixed formulation for Poisson equation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../biharmonic/demo_biharmonic.py.html">Biharmonic equation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../auto-adaptive-poisson/demo_auto-adaptive-poisson.py.html">Auto adaptive Poisson equation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../cahn-hilliard/demo_cahn-hilliard.py.html">Cahn-Hilliard equation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../maxwell-eigenvalues/demo_maxwell-eigenvalues.py.html">Stable and unstable finite elements for the Maxwell eigenvalue problem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../hyperelasticity/demo_hyperelasticity.py.html">Hyperelasticity</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Nonlinear Poisson equation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#equation-and-problem-definition">Equation and problem definition</a></li>
<li class="toctree-l4"><a class="reference internal" href="#implementation">Implementation</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../singular-poisson/demo_singular-poisson.py.html">Singular Poisson</a></li>
<li class="toctree-l3"><a class="reference internal" href="../neumann-poisson/demo_neumann-poisson.py.html">Poisson equation with pure Neumann boundary conditions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../nonmatching-interpolation/demo_nonmatching-interpolation.py.html">Interpolation from a non-matching mesh</a></li>
<li class="toctree-l3"><a class="reference internal" href="../stokes-iterative/demo_stokes-iterative.py.html">Stokes equations with an iterative solver</a></li>
<li class="toctree-l3"><a class="reference internal" href="../elastodynamics/demo_elastodynamics.py.html">Time-integration of elastodynamics equation</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../api.html">Python API reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developer.html">Developer resources</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ChangeLog.html">Change log</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">DOLFIN</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../demos.html">Demos</a> &raquo;</li>
        
      <li>Nonlinear Poisson equation</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/demos/nonlinear-poisson/demo_nonlinear-poisson.py.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="nonlinear-poisson-equation">
<span id="demo-nonlinear-poisson"></span><h1>Nonlinear Poisson equation<a class="headerlink" href="#nonlinear-poisson-equation" title="Permalink to this headline">¶</a></h1>
<p>This demo is implemented in a single Python file,
<a class="reference download internal" download="" href="../../_downloads/efbcc202c4bfb0c8024d09ef2a0a1606/demo_nonlinear-poisson.py"><code class="xref download docutils literal notranslate"><span class="pre">demo_nonlinear-poisson.py</span></code></a>, which contains both the
variational form and the solver.</p>
<p>This demo illustrates how to:</p>
<ul class="simple">
<li><p>Solve a nonlinear partial differential equation (in this case a
nonlinear variant of Poisson’s equation)</p></li>
<li><p>Create and apply Dirichlet boundary conditions</p></li>
<li><p>Define an <code class="xref py py-class docutils literal notranslate"><span class="pre">Expression</span></code></p></li>
<li><p>Define a <code class="xref py py-class docutils literal notranslate"><span class="pre">FunctionSpace</span></code></p></li>
<li><p>Create a <code class="xref py py-class docutils literal notranslate"><span class="pre">SubDomain</span></code></p></li>
</ul>
<p>The solution for <span class="math notranslate nohighlight">\(u\)</span> in this demo will look as follows:</p>
<a class="reference internal image-reference" href="../../_images/plot_u.png"><img alt="../../_images/plot_u.png" src="../../_images/plot_u.png" style="width: 450.0px; height: 300.0px;" /></a>
<p>and the gradient of <span class="math notranslate nohighlight">\(u\)</span> will look like this:</p>
<a class="reference internal image-reference" href="../../_images/plot_u_gradient.png"><img alt="../../_images/plot_u_gradient.png" src="../../_images/plot_u_gradient.png" style="width: 450.0px; height: 300.0px;" /></a>
<div class="section" id="equation-and-problem-definition">
<h2>Equation and problem definition<a class="headerlink" href="#equation-and-problem-definition" title="Permalink to this headline">¶</a></h2>
<p>For a domain <span class="math notranslate nohighlight">\(\Omega \subset \mathbb{R}^N\)</span> with boundary
<span class="math notranslate nohighlight">\(\partial \Omega = \Gamma_{D} \cup \Gamma_{N}\)</span>, we consider the
following nonlinear Poisson equation with given boundary conditions:</p>
<p>Here <span class="math notranslate nohighlight">\(f\)</span> is input data and <span class="math notranslate nohighlight">\(n\)</span> denotes the outward
directed boundary normal. The nonlinear variational form can be
written in the following canonical form: find <span class="math notranslate nohighlight">\(u \in V\)</span> such
that</p>
<div class="math notranslate nohighlight">
\[F(u;v) = 0 \quad \forall \, v \in \hat{V}\]</div>
<p>Here <span class="math notranslate nohighlight">\(F:V\times\hat{V}\rightarrow\mathbb{R}\)</span> is a semilinear
form, linear in the argument subsequent to the semicolon, and
<span class="math notranslate nohighlight">\(V\)</span> is some suitable function space. The semilinear form is
defined as follows:</p>
<div class="math notranslate nohighlight">
\[F(u;v) = \int_\Omega (1 + u^2)\cdot\nabla u \cdot \nabla v - f v \,{\rm dx} = 0.\]</div>
<p>To solve the nonlinear system <span class="math notranslate nohighlight">\(b(U) = 0\)</span> by Newton’s method we
compute the Jacobian <span class="math notranslate nohighlight">\(A = b'\)</span>, where <span class="math notranslate nohighlight">\(U\)</span> is the
coefficients of the linear combination in the finite element solution
<span class="math notranslate nohighlight">\(u_h = \sum_{j=1}^{N}U_j\phi_j, \;
b:\mathbb{R}^N\rightarrow\mathbb{R}^N\)</span> and</p>
<div class="math notranslate nohighlight">
\[b_i(U) = F(u_h;\hat{\phi}_i),\quad i = 1,2,\dotsc,N.\]</div>
<p>Linearizing the semilinear form <span class="math notranslate nohighlight">\(F\)</span> around <span class="math notranslate nohighlight">\(u = u_h\)</span>, we obtain</p>
<div class="math notranslate nohighlight">
\[F'(u_h;\delta u,v) = \int_\Omega [(2 u_h \delta u\nabla u_h)\cdot\nabla v + ((1+u_h^2)\nabla\delta u)\nabla v] \,{\rm dx}\]</div>
<p>We note that for each fixed <span class="math notranslate nohighlight">\(u_h\)</span>, <span class="math notranslate nohighlight">\(a =
F'(u_h;\,\cdot\,,\,\cdot\,)\)</span> is a bilinear form and <span class="math notranslate nohighlight">\(L =
F(u_h;\,\cdot\,,\,\cdot\,)\)</span> is a linear form. In each Newton
iteration, we thus solve a linear variational problem of the canonical
form: find <span class="math notranslate nohighlight">\(\delta u \in V_{h,0}\)</span> such that</p>
<div class="math notranslate nohighlight">
\[F'(u_h;\delta u,v) = -F(u_h;v)\quad\forall\,v\in\hat{V}_h.\]</div>
<p>In this demo, we shall consider the following definitions of the input
function, the domain, and the boundaries:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\Omega = [0,1] \times [0,1]\,\,\,\)</span> (a unit square)</p></li>
<li><p><span class="math notranslate nohighlight">\(\Gamma_{D} = \{(1, y) \subset \partial \Omega\}\,\,\,\)</span> (Dirichlet boundary)</p></li>
<li><p><span class="math notranslate nohighlight">\(\Gamma_{N} = \{(x, 0) \cup (x, 1) \cup (0, y) \subset \partial \Omega\}\,\,\,\)</span> (Neumann boundary)</p></li>
<li><p><span class="math notranslate nohighlight">\(f(x, y) = x\sin(y)\,\,\,\)</span> (source term)</p></li>
</ul>
</div>
<div class="section" id="implementation">
<h2>Implementation<a class="headerlink" href="#implementation" title="Permalink to this headline">¶</a></h2>
<p>This description goes through the implementation (in
<a class="reference download internal" download="" href="../../_downloads/efbcc202c4bfb0c8024d09ef2a0a1606/demo_nonlinear-poisson.py"><code class="xref download docutils literal notranslate"><span class="pre">demo_nonlinear-poisson.py</span></code></a>) of a solver for the above
described nonlinear Poisson equation step-by-step.</p>
<p>First, the matplotlib and <code class="xref py py-mod docutils literal notranslate"><span class="pre">dolfin</span></code> modules are imported:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">dolfin</span> <span class="kn">import</span> <span class="o">*</span>
</pre></div>
</div>
<p>Next, we want to consider the Dirichlet boundary condition. A simple
Python function, returning a boolean, can be used to define the
subdomain for the Dirichlet boundary condition (<span class="math notranslate nohighlight">\(\Gamma_D\)</span>). The
function should return True for those points inside the subdomain and
False for the points outside. In our case, we want to say that the
points <span class="math notranslate nohighlight">\((x, y)\)</span> such that <span class="math notranslate nohighlight">\(x = 1\)</span> are inside on the inside
of <span class="math notranslate nohighlight">\(\Gamma_D\)</span>. (Note that because of rounding-off errors, it is
often wise to instead specify <span class="math notranslate nohighlight">\(|x - 1| &lt; \epsilon\)</span>, where
<span class="math notranslate nohighlight">\(\epsilon\)</span> is a small number (such as machine precision).):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Sub domain for Dirichlet boundary condition</span>
<span class="k">class</span> <span class="nc">DirichletBoundary</span><span class="p">(</span><span class="n">SubDomain</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">inside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">DOLFIN_EPS</span> <span class="ow">and</span> <span class="n">on_boundary</span>
</pre></div>
</div>
<p>We then define a mesh of the domain and a finite element function
space V relative to this mesh. We use the built-in mesh provided by
the class <code class="xref py py-class docutils literal notranslate"><span class="pre">UnitSquareMesh</span></code>. In order to create a mesh
consisting of <span class="math notranslate nohighlight">\(32 \times 32\)</span> squares with each square divided
into two triangles, we do as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create mesh and define function space</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitSquareMesh</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>
<span class="n">File</span><span class="p">(</span><span class="s2">&quot;mesh.pvd&quot;</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">mesh</span>

<span class="n">V</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s2">&quot;CG&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>The second argument to <code class="xref py py-class docutils literal notranslate"><span class="pre">FunctionSpace</span></code> is the finite element family,
while the third argument specifies the polynomial degree. Thus, in
this case, we use ‘CG’, for Continuous Galerkin, as a synonym for
‘Lagrange’. With degree 1, we simply get the standard linear Lagrange
element, which is a triangle with nodes at the three vertices (or in
other words, continuous piecewise linear polynomials).</p>
<p>The Dirichlet boundary condition can be created using the class
<code class="xref py py-class docutils literal notranslate"><span class="pre">DirichletBC</span></code>. A
<code class="xref py py-class docutils literal notranslate"><span class="pre">DirichletBC</span></code> takes three
arguments: the function space the boundary condition applies to, the
value of the boundary condition, and the part of the boundary on which
the condition applies. In our example, the function space is V, the
value of the boundary condition (1.0) can be represented using a
Constant and the Dirichlet boundary is defined above. The definition
of the Dirichlet boundary condition then looks as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Define boundary condition</span>
<span class="n">g</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>
<span class="n">bc</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">DirichletBoundary</span><span class="p">())</span>
</pre></div>
</div>
<p>Next, we want to express the variational problem. First, we need to
specify the function u which represents the solution. Upon
initialization, it is simply set to the zero function, which will
represent the initial guess <span class="math notranslate nohighlight">\(u_0\)</span>. A <code class="xref py py-class docutils literal notranslate"><span class="pre">Function</span></code> represents a function living in a
finite element function space. The test function <span class="math notranslate nohighlight">\(v\)</span> is
specified, also living in the function space <span class="math notranslate nohighlight">\(V\)</span>. We do this by
defining a <code class="xref py py-class docutils literal notranslate"><span class="pre">Function</span></code> and a
<code class="xref py py-class docutils literal notranslate"><span class="pre">TestFunction</span></code> on
the previously defined <code class="xref py py-class docutils literal notranslate"><span class="pre">FunctionSpace</span></code> V.</p>
<p>Further, the source <span class="math notranslate nohighlight">\(f\)</span> is involved in the variational forms,
and hence we must specify this. We have <span class="math notranslate nohighlight">\(f\)</span> given by a simple
mathematical formula, which can be easily declared using the
<code class="xref py py-class docutils literal notranslate"><span class="pre">Expression</span></code> class. Note
that the strings defining f use C++ syntax since, for efficiency,
DOLFIN will generate and compile C++ code for this expression at
run-time.</p>
<p>By defining the function in this step and omitting the trial function
we tell FEniCS that the problem is nonlinear. With these ingredients,
we can write down the semilinear form F (using UFL operators). In
summary, this reads:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Define variational problem</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s2">&quot;x[0]*sin(x[1])&quot;</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">F</span> <span class="o">=</span> <span class="n">inner</span><span class="p">((</span><span class="mi">1</span> <span class="o">+</span> <span class="n">u</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span> <span class="o">-</span> <span class="n">f</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span>
</pre></div>
</div>
<p>Now, we have specified the variational forms and can consider the
solution of the variational problem.  Next, we can call the solve
function with the arguments F == 0, u, bc and solver parameters as
follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Compute solution</span>
<span class="n">solve</span><span class="p">(</span><span class="n">F</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bc</span><span class="p">,</span>
      <span class="n">solver_parameters</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;newton_solver&quot;</span><span class="p">:{</span><span class="s2">&quot;relative_tolerance&quot;</span><span class="p">:</span><span class="mf">1e-6</span><span class="p">}})</span>
</pre></div>
</div>
<p>The Newton procedure is considered to have converged when the residual
<span class="math notranslate nohighlight">\(r_n\)</span> at iteration <span class="math notranslate nohighlight">\(n\)</span> is less than the absolute tolerance
or the relative residual <span class="math notranslate nohighlight">\(\frac{r_n}{r_0}\)</span> is less than the
relative tolerance.</p>
<p>A <code class="xref py py-class docutils literal notranslate"><span class="pre">Function</span></code> can be
manipulated in various ways, in particular, it can be plotted and
saved to file. Here, we output the solution to a VTK file (using the
suffix .pvd) for later visualization and also plot it using the plot
command:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Plot solution and solution gradient</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">plot</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s2">&quot;Solution&quot;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">plot</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">title</span><span class="o">=</span><span class="s2">&quot;Solution gradient&quot;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<span class="c1"># Save solution in VTK format</span>
<span class="n">file</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="s2">&quot;nonlinear_poisson.pvd&quot;</span><span class="p">)</span>
<span class="n">file</span> <span class="o">&lt;&lt;</span> <span class="n">u</span>
</pre></div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../singular-poisson/demo_singular-poisson.py.html" class="btn btn-neutral float-right" title="Singular Poisson" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="../hyperelasticity/demo_hyperelasticity.py.html" class="btn btn-neutral float-left" title="Hyperelasticity" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2017, FEniCS Project

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>