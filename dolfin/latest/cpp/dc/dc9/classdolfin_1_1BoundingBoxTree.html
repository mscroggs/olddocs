<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DOLFIN: dolfin::BoundingBoxTree Class Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DOLFIN
   </div>
   <div id="projectbrief">DOLFIN C++ interface</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../df/de3/namespacedolfin.html">dolfin</a></li><li class="navelem"><a class="el" href="../../dc/dc9/classdolfin_1_1BoundingBoxTree.html">BoundingBoxTree</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="../../dc/dee/classdolfin_1_1BoundingBoxTree-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">dolfin::BoundingBoxTree Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="../../d8/d05/BoundingBoxTree_8h_source.html">BoundingBoxTree.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9f3c3fddcb9cb7c0b620bd08803f69db"><td class="memItemLeft" align="right" valign="top"><a id="a9f3c3fddcb9cb7c0b620bd08803f69db"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dc9/classdolfin_1_1BoundingBoxTree.html#a9f3c3fddcb9cb7c0b620bd08803f69db">BoundingBoxTree</a> ()</td></tr>
<tr class="memdesc:a9f3c3fddcb9cb7c0b620bd08803f69db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create empty bounding box tree. <br /></td></tr>
<tr class="separator:a9f3c3fddcb9cb7c0b620bd08803f69db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac777e072a4e9b4d1694844d7165efacf"><td class="memItemLeft" align="right" valign="top"><a id="ac777e072a4e9b4d1694844d7165efacf"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dc9/classdolfin_1_1BoundingBoxTree.html#ac777e072a4e9b4d1694844d7165efacf">~BoundingBoxTree</a> ()</td></tr>
<tr class="memdesc:ac777e072a4e9b4d1694844d7165efacf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:ac777e072a4e9b4d1694844d7165efacf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47f49f66e41ee61867b3661dad28c622"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dc9/classdolfin_1_1BoundingBoxTree.html#a47f49f66e41ee61867b3661dad28c622">build</a> (const <a class="el" href="../../da/dfc/classdolfin_1_1Mesh.html">Mesh</a> &amp;mesh)</td></tr>
<tr class="separator:a47f49f66e41ee61867b3661dad28c622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89501ef2951aad0cb5e7e17457c94ba1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dc9/classdolfin_1_1BoundingBoxTree.html#a89501ef2951aad0cb5e7e17457c94ba1">build</a> (const <a class="el" href="../../da/dfc/classdolfin_1_1Mesh.html">Mesh</a> &amp;mesh, std::size_t tdim)</td></tr>
<tr class="separator:a89501ef2951aad0cb5e7e17457c94ba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f898acf755cd3898e24e40b236f5049"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dc9/classdolfin_1_1BoundingBoxTree.html#a3f898acf755cd3898e24e40b236f5049">build</a> (const std::vector&lt; <a class="el" href="../../d3/d1a/classdolfin_1_1Point.html">Point</a> &gt; &amp;points, std::size_t gdim)</td></tr>
<tr class="separator:a3f898acf755cd3898e24e40b236f5049"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a192bb0fd4ae2dc2cf24f327beaad26e9"><td class="memItemLeft" align="right" valign="top">std::vector&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dc9/classdolfin_1_1BoundingBoxTree.html#a192bb0fd4ae2dc2cf24f327beaad26e9">compute_collisions</a> (const <a class="el" href="../../d3/d1a/classdolfin_1_1Point.html">Point</a> &amp;point) const</td></tr>
<tr class="separator:a192bb0fd4ae2dc2cf24f327beaad26e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c76900c8e17d9e4d656a4d64c47b27f"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; unsigned int &gt;, std::vector&lt; unsigned int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dc9/classdolfin_1_1BoundingBoxTree.html#a2c76900c8e17d9e4d656a4d64c47b27f">compute_collisions</a> (const <a class="el" href="../../dc/dc9/classdolfin_1_1BoundingBoxTree.html">BoundingBoxTree</a> &amp;tree) const</td></tr>
<tr class="separator:a2c76900c8e17d9e4d656a4d64c47b27f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29c899943b77449764b727524d5c4631"><td class="memItemLeft" align="right" valign="top">std::vector&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dc9/classdolfin_1_1BoundingBoxTree.html#a29c899943b77449764b727524d5c4631">compute_entity_collisions</a> (const <a class="el" href="../../d3/d1a/classdolfin_1_1Point.html">Point</a> &amp;point) const</td></tr>
<tr class="separator:a29c899943b77449764b727524d5c4631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43917625bb08efe59dccf0fe02fa3bd8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dc9/classdolfin_1_1BoundingBoxTree.html#a43917625bb08efe59dccf0fe02fa3bd8">compute_process_collisions</a> (const <a class="el" href="../../d3/d1a/classdolfin_1_1Point.html">Point</a> &amp;point) const</td></tr>
<tr class="separator:a43917625bb08efe59dccf0fe02fa3bd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4ffa66616b112725e334740177ec716"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; unsigned int &gt;, std::vector&lt; unsigned int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dc9/classdolfin_1_1BoundingBoxTree.html#ac4ffa66616b112725e334740177ec716">compute_entity_collisions</a> (const <a class="el" href="../../dc/dc9/classdolfin_1_1BoundingBoxTree.html">BoundingBoxTree</a> &amp;tree) const</td></tr>
<tr class="separator:ac4ffa66616b112725e334740177ec716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87f5219e1e36b0a654a8ca44f71ce74a"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dc9/classdolfin_1_1BoundingBoxTree.html#a87f5219e1e36b0a654a8ca44f71ce74a">compute_first_collision</a> (const <a class="el" href="../../d3/d1a/classdolfin_1_1Point.html">Point</a> &amp;point) const</td></tr>
<tr class="separator:a87f5219e1e36b0a654a8ca44f71ce74a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae13ccea1a9bfc56d4180e472a840e9aa"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dc9/classdolfin_1_1BoundingBoxTree.html#ae13ccea1a9bfc56d4180e472a840e9aa">compute_first_entity_collision</a> (const <a class="el" href="../../d3/d1a/classdolfin_1_1Point.html">Point</a> &amp;point) const</td></tr>
<tr class="separator:ae13ccea1a9bfc56d4180e472a840e9aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e7103488193472c84b9425def42c07e"><td class="memItemLeft" align="right" valign="top">std::pair&lt; unsigned int, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dc9/classdolfin_1_1BoundingBoxTree.html#a8e7103488193472c84b9425def42c07e">compute_closest_entity</a> (const <a class="el" href="../../d3/d1a/classdolfin_1_1Point.html">Point</a> &amp;point) const</td></tr>
<tr class="separator:a8e7103488193472c84b9425def42c07e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67220a3d54c029fdea3927117863a6c9"><td class="memItemLeft" align="right" valign="top">std::pair&lt; unsigned int, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dc9/classdolfin_1_1BoundingBoxTree.html#a67220a3d54c029fdea3927117863a6c9">compute_closest_point</a> (const <a class="el" href="../../d3/d1a/classdolfin_1_1Point.html">Point</a> &amp;point) const</td></tr>
<tr class="separator:a67220a3d54c029fdea3927117863a6c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adacb300c7cf69a09066485b68515ced7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dc9/classdolfin_1_1BoundingBoxTree.html#adacb300c7cf69a09066485b68515ced7">collides</a> (const <a class="el" href="../../d3/d1a/classdolfin_1_1Point.html">Point</a> &amp;point) const</td></tr>
<tr class="separator:adacb300c7cf69a09066485b68515ced7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c0b073f9bac5c05128ca7d81c503ee0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dc9/classdolfin_1_1BoundingBoxTree.html#a5c0b073f9bac5c05128ca7d81c503ee0">collides_entity</a> (const <a class="el" href="../../d3/d1a/classdolfin_1_1Point.html">Point</a> &amp;point) const</td></tr>
<tr class="separator:a5c0b073f9bac5c05128ca7d81c503ee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class implements a (distributed) axis aligned bounding box tree (AABB tree). Bounding box trees can be created from meshes and [other data structures, to be filled in]. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a47f49f66e41ee61867b3661dad28c622"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47f49f66e41ee61867b3661dad28c622">&#9670;&nbsp;</a></span>build() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BoundingBoxTree::build </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/dfc/classdolfin_1_1Mesh.html">Mesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Build bounding box tree for cells of mesh.</p>
<p><em>Arguments</em> mesh (<em><a class="el" href="../../da/dfc/classdolfin_1_1Mesh.html">Mesh</a></em>) The mesh for which to compute the bounding box tree. </p>

</div>
</div>
<a id="a89501ef2951aad0cb5e7e17457c94ba1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89501ef2951aad0cb5e7e17457c94ba1">&#9670;&nbsp;</a></span>build() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BoundingBoxTree::build </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/dfc/classdolfin_1_1Mesh.html">Mesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>tdim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Build bounding box tree for mesh entities of given dimension.</p>
<p><em>Arguments</em> mesh (<em><a class="el" href="../../da/dfc/classdolfin_1_1Mesh.html">Mesh</a></em>) The mesh for which to compute the bounding box tree. dimension (std::size_t) The entity dimension (topological dimension) for which to compute the bounding box tree. </p>

</div>
</div>
<a id="a3f898acf755cd3898e24e40b236f5049"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f898acf755cd3898e24e40b236f5049">&#9670;&nbsp;</a></span>build() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BoundingBoxTree::build </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="../../d3/d1a/classdolfin_1_1Point.html">Point</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>gdim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Build bounding box tree for point cloud.</p>
<p><em>Arguments</em> points (std::vector&lt;<em><a class="el" href="../../d3/d1a/classdolfin_1_1Point.html">Point</a></em>&gt;) The list of points. gdim (std::size_t) The geometric dimension. </p>

</div>
</div>
<a id="adacb300c7cf69a09066485b68515ced7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adacb300c7cf69a09066485b68515ced7">&#9670;&nbsp;</a></span>collides()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool BoundingBoxTree::collides </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d3/d1a/classdolfin_1_1Point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check whether given point collides with the bounding box tree. This is equivalent to calling compute_first_collision and checking whether any collision was detected.</p>
<p><em>Returns</em> bool True iff the point is inside the tree. </p>

</div>
</div>
<a id="a5c0b073f9bac5c05128ca7d81c503ee0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c0b073f9bac5c05128ca7d81c503ee0">&#9670;&nbsp;</a></span>collides_entity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool BoundingBoxTree::collides_entity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d3/d1a/classdolfin_1_1Point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check whether given point collides with any entity contained in the bounding box tree. This is equivalent to calling compute_first_entity_collision and checking whether any collision was detected.</p>
<p><em>Returns</em> bool True iff the point is inside the tree. </p>

</div>
</div>
<a id="a8e7103488193472c84b9425def42c07e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e7103488193472c84b9425def42c07e">&#9670;&nbsp;</a></span>compute_closest_entity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; unsigned int, double &gt; BoundingBoxTree::compute_closest_entity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d3/d1a/classdolfin_1_1Point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute closest entity to <em><a class="el" href="../../d3/d1a/classdolfin_1_1Point.html">Point</a></em>.</p>
<p><em>Returns</em> unsigned int The local index for the entity that is closest to the point. If more than one entity is at the same distance (or point contained in entity), then the first entity is returned. double The distance to the closest entity.</p>
<p><em>Arguments</em> point (<em><a class="el" href="../../d3/d1a/classdolfin_1_1Point.html">Point</a></em>) The point. </p>

</div>
</div>
<a id="a67220a3d54c029fdea3927117863a6c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67220a3d54c029fdea3927117863a6c9">&#9670;&nbsp;</a></span>compute_closest_point()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; unsigned int, double &gt; BoundingBoxTree::compute_closest_point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d3/d1a/classdolfin_1_1Point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute closest point to <em><a class="el" href="../../d3/d1a/classdolfin_1_1Point.html">Point</a></em>. This function assumes that the tree has been built for a point cloud.</p>
<p>Developer note: This function should not be confused with computing the closest point in all entities of a mesh. That function could be added with relative ease since we actually compute the closest points to get the distance in the above function (compute_closest_entity) inside the specialized implementations in TetrahedronCell.cpp etc.</p>
<p><em>Returns</em> unsigned int The local index for the point that is closest to the point. If more than one point is at the same distance (or point contained in entity), then the first point is returned. double The distance to the closest point.</p>
<p><em>Arguments</em> point (<em><a class="el" href="../../d3/d1a/classdolfin_1_1Point.html">Point</a></em>) The point. </p>

</div>
</div>
<a id="a192bb0fd4ae2dc2cf24f327beaad26e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a192bb0fd4ae2dc2cf24f327beaad26e9">&#9670;&nbsp;</a></span>compute_collisions() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; unsigned int &gt; BoundingBoxTree::compute_collisions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d3/d1a/classdolfin_1_1Point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute all collisions between bounding boxes and <em><a class="el" href="../../d3/d1a/classdolfin_1_1Point.html">Point</a></em>.</p>
<p><em>Returns</em> std::vector&lt;unsigned int&gt; A list of local indices for entities contained in (leaf) bounding boxes that collide with (intersect) the given point.</p>
<p><em>Arguments</em> point (<em><a class="el" href="../../d3/d1a/classdolfin_1_1Point.html">Point</a></em>) The point. </p>

</div>
</div>
<a id="a2c76900c8e17d9e4d656a4d64c47b27f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c76900c8e17d9e4d656a4d64c47b27f">&#9670;&nbsp;</a></span>compute_collisions() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; unsigned int &gt;, std::vector&lt; unsigned int &gt; &gt; BoundingBoxTree::compute_collisions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dc/dc9/classdolfin_1_1BoundingBoxTree.html">BoundingBoxTree</a> &amp;&#160;</td>
          <td class="paramname"><em>tree</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute all collisions between bounding boxes and <em><a class="el" href="../../dc/dc9/classdolfin_1_1BoundingBoxTree.html">BoundingBoxTree</a></em>.</p>
<p><em>Returns</em> std::vector&lt;unsigned int&gt; A list of local indices for entities in this tree that collide with (intersect) entities in other tree. std::vector&lt;unsigned int&gt; A list of local indices for entities in other tree that collide with (intersect) entities in this tree.</p>
<p>The two lists have equal length and contain matching entities, such that entity <code>i</code> in the first list collides with entity <code>i</code> in the second list.</p>
<p>Note that this means that the entity lists may contain duplicate entities since a single entity may collide with several different entities.</p>
<p><em>Arguments</em> tree (<em><a class="el" href="../../dc/dc9/classdolfin_1_1BoundingBoxTree.html">BoundingBoxTree</a></em>) The bounding box tree.</p>
<p>Note that this function only checks collisions between bounding boxes of entities. It does not check that the entities themselves actually collide. To compute entity collisions, use the function compute_entity_collisions. </p>

</div>
</div>
<a id="a29c899943b77449764b727524d5c4631"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29c899943b77449764b727524d5c4631">&#9670;&nbsp;</a></span>compute_entity_collisions() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; unsigned int &gt; BoundingBoxTree::compute_entity_collisions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d3/d1a/classdolfin_1_1Point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute all collisions between entities and <em><a class="el" href="../../d3/d1a/classdolfin_1_1Point.html">Point</a></em>.</p>
<p><em>Returns</em> std::vector&lt;unsigned int&gt; A list of local indices for entities that collide with (intersect) the given point.</p>
<p><em>Arguments</em> point (<em><a class="el" href="../../d3/d1a/classdolfin_1_1Point.html">Point</a></em>) The point. </p>

</div>
</div>
<a id="ac4ffa66616b112725e334740177ec716"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4ffa66616b112725e334740177ec716">&#9670;&nbsp;</a></span>compute_entity_collisions() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; unsigned int &gt;, std::vector&lt; unsigned int &gt; &gt; BoundingBoxTree::compute_entity_collisions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dc/dc9/classdolfin_1_1BoundingBoxTree.html">BoundingBoxTree</a> &amp;&#160;</td>
          <td class="paramname"><em>tree</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute all collisions between entities and <em><a class="el" href="../../dc/dc9/classdolfin_1_1BoundingBoxTree.html">BoundingBoxTree</a></em>.</p>
<p><em>Returns</em> std::vector&lt;unsigned int&gt; A list of local indices for entities in this tree that collide with (intersect) entities in other tree. std::vector&lt;unsigned int&gt; A list of local indices for entities in other tree that collide with (intersect) entities in this tree.</p>
<p>The two lists have equal length and contain matching entities, such that entity <code>i</code> in the first list collides with entity <code>i</code> in the second list.</p>
<p>Note that this means that the entity lists may contain duplicate entities since a single entity may collide with several different entities.</p>
<p><em>Arguments</em> tree (<em><a class="el" href="../../dc/dc9/classdolfin_1_1BoundingBoxTree.html">BoundingBoxTree</a></em>) The bounding box tree. </p>

</div>
</div>
<a id="a87f5219e1e36b0a654a8ca44f71ce74a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87f5219e1e36b0a654a8ca44f71ce74a">&#9670;&nbsp;</a></span>compute_first_collision()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int BoundingBoxTree::compute_first_collision </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d3/d1a/classdolfin_1_1Point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute first collision between bounding boxes and <em><a class="el" href="../../d3/d1a/classdolfin_1_1Point.html">Point</a></em>.</p>
<p><em>Returns</em> unsigned int The local index for the first found entity contained in a (leaf) bounding box that collides with (intersects) the given point. If not found, std::numeric_limits&lt;unsigned int&gt;::max() is returned.</p>
<p><em>Arguments</em> point (<em><a class="el" href="../../d3/d1a/classdolfin_1_1Point.html">Point</a></em>) The point. </p>

</div>
</div>
<a id="ae13ccea1a9bfc56d4180e472a840e9aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae13ccea1a9bfc56d4180e472a840e9aa">&#9670;&nbsp;</a></span>compute_first_entity_collision()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int BoundingBoxTree::compute_first_entity_collision </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d3/d1a/classdolfin_1_1Point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute first collision between entities and <em><a class="el" href="../../d3/d1a/classdolfin_1_1Point.html">Point</a></em>.</p>
<p><em>Returns</em> unsigned int The local index for the first found entity that collides with (intersects) the given point. If not found, std::numeric_limits&lt;unsigned int&gt;::max() is returned.</p>
<p><em>Arguments</em> point (<em><a class="el" href="../../d3/d1a/classdolfin_1_1Point.html">Point</a></em>) The point. </p>

</div>
</div>
<a id="a43917625bb08efe59dccf0fe02fa3bd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43917625bb08efe59dccf0fe02fa3bd8">&#9670;&nbsp;</a></span>compute_process_collisions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; unsigned int &gt; BoundingBoxTree::compute_process_collisions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d3/d1a/classdolfin_1_1Point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute all collisions between process bounding boxes and <em><a class="el" href="../../d3/d1a/classdolfin_1_1Point.html">Point</a></em>. Effectively a list of processes which may contain the <em><a class="el" href="../../d3/d1a/classdolfin_1_1Point.html">Point</a></em>.</p>
<p><em>Returns</em> std::vector&lt;unsigned int&gt; A list of process numbers where the <em><a class="el" href="../../da/dfc/classdolfin_1_1Mesh.html">Mesh</a></em> may collide with (intersect) the given point.</p>
<p><em>Arguments</em> point (<em><a class="el" href="../../d3/d1a/classdolfin_1_1Point.html">Point</a></em>) The point. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/fenics/shared/dolfin/dolfin/geometry/<a class="el" href="../../d8/d05/BoundingBoxTree_8h_source.html">BoundingBoxTree.h</a></li>
<li>/home/fenics/shared/dolfin/dolfin/geometry/BoundingBoxTree.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
