

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Poisson equation with multiple subdomains &mdash; DOLFIN  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> DOLFIN
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../using.html">Using DOLFIN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../demos.html">Demos</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api.html">Python API reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developer.html">Developer resources</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ChangeLog.html">Change log</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">DOLFIN</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
      <li>Poisson equation with multiple subdomains</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/demos/subdomains-poisson/documentation.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="poisson-equation-with-multiple-subdomains">
<span id="demo-pde-subdomains-poisson-documentation"></span><h1>Poisson equation with multiple subdomains<a class="headerlink" href="#poisson-equation-with-multiple-subdomains" title="Permalink to this headline">¶</a></h1>
<p>This demo is implemented in a single Python file,
<a class="reference download internal" download="" href="../../_downloads/539e17922806e487ae29f806ce86169a/demo_subdomains-poisson.py"><code class="xref download docutils literal notranslate"><span class="pre">demo_subdomains-poisson.py</span></code></a>, which contains both the
variational forms and the solver. We suggest that you familiarize
yourself with the <span class="xref std std-ref">Poisson demo</span> before studying this example,
as some of the more standard steps will be described in less detail.</p>
<div class="section" id="implementation">
<h2>Implementation<a class="headerlink" href="#implementation" title="Permalink to this headline">¶</a></h2>
<p>This description goes through the implementation (in
<a class="reference download internal" download="" href="../../_downloads/539e17922806e487ae29f806ce86169a/demo_subdomains-poisson.py"><code class="xref download docutils literal notranslate"><span class="pre">demo_subdomains-poisson.py</span></code></a>) of a solver for the above
described equation.</p>
<p>In this example, different boundary conditions are prescribed on
different parts of the boundaries, and different parts of the interior
have different material properties. This information must be made
available to the solver.  One way of doing this, is to tag the
different subregions with different (integer) labels, and later
integrate over the specified regions. DOLFIN provides a class
<code class="xref py py-class docutils literal notranslate"><span class="pre">MeshFunction</span></code> which is useful for
these types of operations: instances of this class represent functions
over mesh entities (such as over cells or over facets). Mesh functions
can be read from file or, if explicit formulae for the domains are
known, they can be constructed by way of instances of the
<code class="xref py py-class docutils literal notranslate"><span class="pre">SubDomain</span></code> class. The latter is the
case here, so we begin by defining the left, right, top and bottom
boundaries, and the interior obstacle domain using the
<code class="xref py py-class docutils literal notranslate"><span class="pre">SubDomain</span></code> class and creating
instances of these classes.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">dolfin</span> <span class="kn">import</span> <span class="o">*</span>

<span class="c1"># Create classes for defining parts of the boundaries and the interior</span>
<span class="c1"># of the domain</span>
<span class="k">class</span> <span class="nc">Left</span><span class="p">(</span><span class="n">SubDomain</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">inside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">near</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mf">0.0</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Right</span><span class="p">(</span><span class="n">SubDomain</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">inside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">near</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mf">1.0</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Bottom</span><span class="p">(</span><span class="n">SubDomain</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">inside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">near</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mf">0.0</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Top</span><span class="p">(</span><span class="n">SubDomain</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">inside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">near</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mf">1.0</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Obstacle</span><span class="p">(</span><span class="n">SubDomain</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">inside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">between</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">))</span> <span class="ow">and</span> <span class="n">between</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)))</span>

<span class="c1"># Initialize sub-domain instances</span>
<span class="n">left</span> <span class="o">=</span> <span class="n">Left</span><span class="p">()</span>
<span class="n">top</span> <span class="o">=</span> <span class="n">Top</span><span class="p">()</span>
<span class="n">right</span> <span class="o">=</span> <span class="n">Right</span><span class="p">()</span>
<span class="n">bottom</span> <span class="o">=</span> <span class="n">Bottom</span><span class="p">()</span>
<span class="n">obstacle</span> <span class="o">=</span> <span class="n">Obstacle</span><span class="p">()</span>
</pre></div>
</div>
<p>Note that the DOLFIN functions <code class="xref py py-func docutils literal notranslate"><span class="pre">near</span></code> and
<code class="xref py py-func docutils literal notranslate"><span class="pre">between</span></code> provide robust ways of testing
whether a coordinate is (to within machine precision) close to a given
numerical value and in a range of values, respectively.</p>
<p>We next define a mesh of the domain:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitSquareMesh</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>
</pre></div>
</div>
<p>The above subdomains are defined with the sole purpose of populating
mesh functions. (For more complicated geometries, the mesh functions
would typically be provided by other means.) We define a <code class="xref py py-class docutils literal notranslate"><span class="pre">MeshFunction</span></code> over the mesh cells to indicate which cells that correspond to
the different interior subregions <span class="math notranslate nohighlight">\(\Omega_0\)</span> and
<span class="math notranslate nohighlight">\(\Omega_1\)</span>. Those in the interior rectangle will be tagged by
<cite>1</cite>, while the remainder is tagged by <cite>0</cite>. We can set all the values
of a <code class="xref py py-class docutils literal notranslate"><span class="pre">MeshFunction</span></code> to a given
value using the <code class="xref py py-func docutils literal notranslate"><span class="pre">set_all</span></code> method.  So, in order to
accomplish what we want, we can set all values to <cite>0</cite> first, and then
we can use the <code class="docutils literal notranslate"><span class="pre">obstacle</span></code> instance to mark the cells identified as
inside the obstacle region by <cite>1</cite> (thus overwriting the previous
value):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Initialize mesh function for interior domains</span>
<span class="n">domains</span> <span class="o">=</span> <span class="n">MeshFunction</span><span class="p">(</span><span class="s2">&quot;size_t&quot;</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">topology</span><span class="p">()</span><span class="o">.</span><span class="n">dim</span><span class="p">())</span>
<span class="n">domains</span><span class="o">.</span><span class="n">set_all</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">obstacle</span><span class="o">.</span><span class="n">mark</span><span class="p">(</span><span class="n">domains</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>We can do the same for the boundaries using a <code class="xref py py-class docutils literal notranslate"><span class="pre">MeshFunction</span></code> defined ove the topological dimension `
mesh.topology().dim()-1`. We first tag all the edges by <code class="docutils literal notranslate"><span class="pre">0</span></code>, then
the edges on the left by <code class="docutils literal notranslate"><span class="pre">1</span></code>, on the top by <code class="docutils literal notranslate"><span class="pre">2</span></code>, on the right by
<code class="docutils literal notranslate"><span class="pre">3</span></code> and on the bottom by <code class="docutils literal notranslate"><span class="pre">4</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Initialize mesh function for boundary domains</span>
<span class="n">boundaries</span> <span class="o">=</span> <span class="n">MeshFunction</span><span class="p">(</span><span class="s2">&quot;size_t&quot;</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">topology</span><span class="p">()</span><span class="o">.</span><span class="n">dim</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="n">boundaries</span><span class="o">.</span><span class="n">set_all</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">left</span><span class="o">.</span><span class="n">mark</span><span class="p">(</span><span class="n">boundaries</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">top</span><span class="o">.</span><span class="n">mark</span><span class="p">(</span><span class="n">boundaries</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">right</span><span class="o">.</span><span class="n">mark</span><span class="p">(</span><span class="n">boundaries</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">bottom</span><span class="o">.</span><span class="n">mark</span><span class="p">(</span><span class="n">boundaries</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
<p>Now that the geometry is defined and labeled, we can move on to
defining the input source functions:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Define input data</span>
<span class="n">a0</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>
<span class="n">a1</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mf">0.01</span><span class="p">)</span>
<span class="n">g_L</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s2">&quot;- 10*exp(- pow(x[1] - 0.5, 2))&quot;</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">g_R</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>
</pre></div>
</div>
<p>Here, <code class="docutils literal notranslate"><span class="pre">a0</span></code> and <code class="docutils literal notranslate"><span class="pre">a1</span></code> represent the values of the coefficient
<span class="math notranslate nohighlight">\(a\)</span> in the two regions of the domain, <code class="docutils literal notranslate"><span class="pre">g_L</span></code> and <code class="docutils literal notranslate"><span class="pre">g_R</span></code>
represent the values of the Neumann boundary condition on the left and
right boundaries respectively, and <code class="docutils literal notranslate"><span class="pre">f</span></code> represents the body source.</p>
<p>We may now move on to define the variational equation. As usual, we
start by defining a finite element function space and basis functions
on this space:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Define function space and basis functions</span>
<span class="n">V</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s2">&quot;CG&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
</pre></div>
</div>
<p>With this function space, we can define the essential (Dirichlet)
boundary conditions on the top and bottom boundaries. These boundaries
correspond to the facets tagged by <code class="docutils literal notranslate"><span class="pre">2</span></code> and <code class="docutils literal notranslate"><span class="pre">4</span></code>, respectively, in
the <code class="docutils literal notranslate"><span class="pre">boundaries</span></code> facet function:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Define Dirichlet boundary conditions at top and bottom boundaries</span>
<span class="n">bcs</span> <span class="o">=</span> <span class="p">[</span><span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">,</span> <span class="n">boundaries</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
       <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">boundaries</span><span class="p">,</span> <span class="mi">4</span><span class="p">)]</span>
</pre></div>
</div>
<p>DOLFIN predefines the “measures” <code class="docutils literal notranslate"><span class="pre">dx</span></code>, <code class="docutils literal notranslate"><span class="pre">ds</span></code> and <code class="docutils literal notranslate"><span class="pre">dS</span></code>
representing integration over cells, exterior facets (that is, facets
on the boundary) and interior facets, respectively. These measures can
take an additional integer argument.  In fact, <code class="docutils literal notranslate"><span class="pre">dx</span></code> defaults to
<code class="docutils literal notranslate"><span class="pre">dx(0)</span></code>, <code class="docutils literal notranslate"><span class="pre">ds</span></code> defaults to <code class="docutils literal notranslate"><span class="pre">ds(0)</span></code>, and <code class="docutils literal notranslate"><span class="pre">dS</span></code> defaults to
<code class="docutils literal notranslate"><span class="pre">dS(0)</span></code>. Integration over subregions can be specified by measures
with different integer labels as arguments. However, we also need to
map the geometry information stored in the mesh functions to these
measures. The easiest way of accomplishing this is to define new
measures with the mesh functions as additional input:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Define new measures associated with the interior domains and</span>
<span class="c1"># exterior boundaries</span>
<span class="n">dx</span> <span class="o">=</span> <span class="n">Measure</span><span class="p">(</span><span class="s1">&#39;dx&#39;</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="n">mesh</span><span class="p">,</span> <span class="n">subdomain_data</span><span class="o">=</span><span class="n">domains</span><span class="p">)</span>
<span class="n">ds</span> <span class="o">=</span> <span class="n">Measure</span><span class="p">(</span><span class="s1">&#39;ds&#39;</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="n">mesh</span><span class="p">,</span> <span class="n">subdomain_data</span><span class="o">=</span><span class="n">boundaries</span><span class="p">)</span>
</pre></div>
</div>
<p>We can now define the variational forms corresponding to the
variational problem above using these measures and the tags for the
different subregions. For simplicity, we define the full form first,
and then extract the left- and right-hand sides using the UFL
functions <code class="xref py py-func docutils literal notranslate"><span class="pre">lhs()</span></code> and <code class="xref py py-func docutils literal notranslate"><span class="pre">rhs()</span></code> afterwards. We can then
<code class="xref py py-func docutils literal notranslate"><span class="pre">solve</span></code> as usual:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Define variational form</span>
<span class="n">F</span> <span class="o">=</span> <span class="p">(</span><span class="n">inner</span><span class="p">(</span><span class="n">a0</span><span class="o">*</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">inner</span><span class="p">(</span><span class="n">a1</span><span class="o">*</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
     <span class="o">-</span> <span class="n">g_L</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">ds</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">g_R</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">ds</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
     <span class="o">-</span> <span class="n">f</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">f</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>

<span class="c1"># Separate left and right hand sides of equation</span>
<span class="n">a</span><span class="p">,</span> <span class="n">L</span> <span class="o">=</span> <span class="n">lhs</span><span class="p">(</span><span class="n">F</span><span class="p">),</span> <span class="n">rhs</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>

<span class="c1"># Solve problem</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">solve</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">L</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bcs</span><span class="p">)</span>
</pre></div>
</div>
<p>Now, we can also evaluate various integrals of the solution or derived
quantities of the solution over different regions, here are some
examples:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Evaluate integral of normal gradient over top boundary</span>
<span class="n">n</span> <span class="o">=</span> <span class="n">FacetNormal</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
<span class="n">m1</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">n</span><span class="p">)</span><span class="o">*</span><span class="n">ds</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">v1</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">m1</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s2">&quot;\int grad(u) * n ds(2) = &quot;</span><span class="p">,</span> <span class="n">v1</span><span class="p">)</span>

<span class="c1"># Evaluate integral of u over the obstacle</span>
<span class="n">m2</span> <span class="o">=</span> <span class="n">u</span><span class="o">*</span><span class="n">dx</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">v2</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">m2</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s2">&quot;\int u dx(1) = &quot;</span><span class="p">,</span> <span class="n">v2</span><span class="p">)</span>
</pre></div>
</div>
<p>We also plot the solution and its gradient:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Plot solution and gradient</span>
<span class="n">plot</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s2">&quot;u&quot;</span><span class="p">)</span>
<span class="n">plot</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">title</span><span class="o">=</span><span class="s2">&quot;Projected grad(u)&quot;</span><span class="p">)</span>
<span class="n">interactive</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="complete-code">
<h2>Complete code<a class="headerlink" href="#complete-code" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>

<span class="kn">from</span> <span class="nn">dolfin</span> <span class="k">import</span> <span class="o">*</span>

<span class="c1"># Create classes for defining parts of the boundaries and the interior</span>
<span class="c1"># of the domain</span>
<span class="k">class</span> <span class="nc">Left</span><span class="p">(</span><span class="n">SubDomain</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">inside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">near</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mf">0.0</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Right</span><span class="p">(</span><span class="n">SubDomain</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">inside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">near</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mf">1.0</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Bottom</span><span class="p">(</span><span class="n">SubDomain</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">inside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">near</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mf">0.0</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Top</span><span class="p">(</span><span class="n">SubDomain</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">inside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">near</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mf">1.0</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Obstacle</span><span class="p">(</span><span class="n">SubDomain</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">inside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">between</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">))</span> <span class="ow">and</span> <span class="n">between</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)))</span>

<span class="c1"># Initialize sub-domain instances</span>
<span class="n">left</span> <span class="o">=</span> <span class="n">Left</span><span class="p">()</span>
<span class="n">top</span> <span class="o">=</span> <span class="n">Top</span><span class="p">()</span>
<span class="n">right</span> <span class="o">=</span> <span class="n">Right</span><span class="p">()</span>
<span class="n">bottom</span> <span class="o">=</span> <span class="n">Bottom</span><span class="p">()</span>
<span class="n">obstacle</span> <span class="o">=</span> <span class="n">Obstacle</span><span class="p">()</span>

<span class="c1"># Define mesh</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitSquareMesh</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>

<span class="c1"># Initialize mesh function for interior domains</span>
<span class="n">domains</span> <span class="o">=</span> <span class="n">MeshFunction</span><span class="p">(</span><span class="s2">&quot;size_t&quot;</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">topology</span><span class="p">()</span><span class="o">.</span><span class="n">dim</span><span class="p">())</span>
<span class="n">domains</span><span class="o">.</span><span class="n">set_all</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">obstacle</span><span class="o">.</span><span class="n">mark</span><span class="p">(</span><span class="n">domains</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="c1"># Initialize mesh function for boundary domains</span>
<span class="n">boundaries</span> <span class="o">=</span> <span class="n">MeshFunction</span><span class="p">(</span><span class="s2">&quot;size_t&quot;</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">topology</span><span class="p">()</span><span class="o">.</span><span class="n">dim</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="n">boundaries</span><span class="o">.</span><span class="n">set_all</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">left</span><span class="o">.</span><span class="n">mark</span><span class="p">(</span><span class="n">boundaries</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">top</span><span class="o">.</span><span class="n">mark</span><span class="p">(</span><span class="n">boundaries</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">right</span><span class="o">.</span><span class="n">mark</span><span class="p">(</span><span class="n">boundaries</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">bottom</span><span class="o">.</span><span class="n">mark</span><span class="p">(</span><span class="n">boundaries</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>

<span class="c1"># Define input data</span>
<span class="n">a0</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>
<span class="n">a1</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mf">0.01</span><span class="p">)</span>
<span class="n">g_L</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s2">&quot;- 10*exp(- pow(x[1] - 0.5, 2))&quot;</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">g_R</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>

<span class="c1"># Define function space and basis functions</span>
<span class="n">V</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s2">&quot;CG&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>

<span class="c1"># Define Dirichlet boundary conditions at top and bottom boundaries</span>
<span class="n">bcs</span> <span class="o">=</span> <span class="p">[</span><span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">,</span> <span class="n">boundaries</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
       <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">boundaries</span><span class="p">,</span> <span class="mi">4</span><span class="p">)]</span>

<span class="c1"># Define new measures associated with the interior domains and</span>
<span class="c1"># exterior boundaries</span>
<span class="n">dx</span> <span class="o">=</span> <span class="n">Measure</span><span class="p">(</span><span class="s1">&#39;dx&#39;</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="n">mesh</span><span class="p">,</span> <span class="n">subdomain_data</span><span class="o">=</span><span class="n">domains</span><span class="p">)</span>
<span class="n">ds</span> <span class="o">=</span> <span class="n">Measure</span><span class="p">(</span><span class="s1">&#39;ds&#39;</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="n">mesh</span><span class="p">,</span> <span class="n">subdomain_data</span><span class="o">=</span><span class="n">boundaries</span><span class="p">)</span>

<span class="c1"># Define variational form</span>
<span class="n">F</span> <span class="o">=</span> <span class="p">(</span><span class="n">inner</span><span class="p">(</span><span class="n">a0</span><span class="o">*</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">inner</span><span class="p">(</span><span class="n">a1</span><span class="o">*</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
     <span class="o">-</span> <span class="n">g_L</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">ds</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">g_R</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">ds</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
     <span class="o">-</span> <span class="n">f</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">f</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>

<span class="c1"># Separate left and right hand sides of equation</span>
<span class="n">a</span><span class="p">,</span> <span class="n">L</span> <span class="o">=</span> <span class="n">lhs</span><span class="p">(</span><span class="n">F</span><span class="p">),</span> <span class="n">rhs</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>

<span class="c1"># Solve problem</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">solve</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">L</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bcs</span><span class="p">)</span>

<span class="c1"># Evaluate integral of normal gradient over top boundary</span>
<span class="n">n</span> <span class="o">=</span> <span class="n">FacetNormal</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
<span class="n">m1</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">n</span><span class="p">)</span><span class="o">*</span><span class="n">ds</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">v1</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">m1</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;\int grad(u) * n ds(2) = &quot;</span><span class="p">,</span> <span class="n">v1</span><span class="p">)</span>

<span class="c1"># Evaluate integral of u over the obstacle</span>
<span class="n">m2</span> <span class="o">=</span> <span class="n">u</span><span class="o">*</span><span class="n">dx</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">v2</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">m2</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;\int u dx(1) = &quot;</span><span class="p">,</span> <span class="n">v2</span><span class="p">)</span>

<span class="c1"># Plot solution</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">plot</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s2">&quot;Solution u&quot;</span><span class="p">)</span>

<span class="c1"># Plot solution and gradient</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">plot</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">title</span><span class="o">=</span><span class="s2">&quot;Projected grad(u)&quot;</span><span class="p">)</span>

<span class="c1"># Show plots</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, FEniCS Project

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>